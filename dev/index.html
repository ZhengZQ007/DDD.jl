<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Index · DDD.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">DDD.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Index</a></li><li><a class="tocitem" href="types/">Types</a></li><li><a class="tocitem" href="io/">IO</a></li><li><a class="tocitem" href="plotting/">Plotting</a></li><li><a class="tocitem" href="theory/">Discrete Dislocation Dynamics</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Index</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Index</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/dcelisgarza/DDD.jl/blob/master/docs/src/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="DDD.jl-1"><a class="docs-heading-anchor" href="#DDD.jl-1">DDD.jl</a><a class="docs-heading-anchor-permalink" href="#DDD.jl-1" title="Permalink"></a></h1><ul><li><a href="#DDD.AbstractCrystalStruct"><code>DDD.AbstractCrystalStruct</code></a></li><li><a href="#DDD.AbstractDistribution"><code>DDD.AbstractDistribution</code></a></li><li><a href="#DDD.AbstractDlnSeg"><code>DDD.AbstractDlnSeg</code></a></li><li><a href="#DDD.AbstractDlnStr"><code>DDD.AbstractDlnStr</code></a></li><li><a href="#DDD.AbstractIntegrator"><code>DDD.AbstractIntegrator</code></a></li><li><a href="#DDD.AbstractMesh"><code>DDD.AbstractMesh</code></a></li><li><a href="#DDD.AbstractMobility"><code>DDD.AbstractMobility</code></a></li><li><a href="#DDD.AbstractShapeFunction"><code>DDD.AbstractShapeFunction</code></a></li><li><a href="#DDD.DislocationLoop"><code>DDD.DislocationLoop</code></a></li><li><a href="#DDD.DislocationNetwork"><code>DDD.DislocationNetwork</code></a></li><li><a href="#DDD.DislocationP"><code>DDD.DislocationP</code></a></li><li><a href="#DDD.IntegrationP"><code>DDD.IntegrationP</code></a></li><li><a href="#DDD.MaterialP"><code>DDD.MaterialP</code></a></li><li><a href="#DDD.SlipSystem"><code>DDD.SlipSystem</code></a></li><li><a href="#DDD.nodeType"><code>DDD.nodeType</code></a></li><li><a href="#DDD.calcSegSegForce-Tuple{DDD.DislocationP,DDD.MaterialP,DislocationNetwork}"><code>DDD.calcSegSegForce</code></a></li><li><a href="#DDD.calcSelfForce-Tuple{DDD.DislocationP,DDD.MaterialP,DislocationNetwork}"><code>DDD.calcSelfForce</code></a></li><li><a href="#DDD.checkNetwork-Tuple{DislocationNetwork}"><code>DDD.checkNetwork</code></a></li><li><a href="#DDD.compStruct-Tuple{Any,Any}"><code>DDD.compStruct</code></a></li><li><a href="#DDD.coordIdx-Union{Tuple{N}, Tuple{DislocationNetwork,Union{Integer, AbstractArray{#s69,N} where #s69&lt;:Integer}}} where N"><code>DDD.coordIdx</code></a></li><li><a href="#DDD.coordLbl-Tuple{DislocationNetwork,Integer}"><code>DDD.coordLbl</code></a></li><li><a href="#DDD.dataCond-Tuple{DislocationNetwork,Symbol,Real}"><code>DDD.dataCond</code></a></li><li><a href="#DDD.extAngle-Tuple{Int64}"><code>DDD.extAngle</code></a></li><li><a href="#DDD.hatStress-Tuple{DDD.RegularCuboidMesh,DDD.DislocationFEMCorrective,AbstractArray{#s68,N} where #s68&lt;:Float64 where N}"><code>DDD.hatStress</code></a></li><li><a href="#DDD.idxCond-Tuple{DislocationNetwork,Symbol,Function,Vararg{Any,N} where N}"><code>DDD.idxCond</code></a></li><li><a href="#DDD.idxLabel-Tuple{DislocationNetwork,Integer}"><code>DDD.idxLabel</code></a></li><li><a href="#DDD.inclusiveComparison-Tuple{Any,Vararg{Any,N} where N}"><code>DDD.inclusiveComparison</code></a></li><li><a href="#DDD.intAngle-Tuple{Int64}"><code>DDD.intAngle</code></a></li><li><a href="#DDD.limits!-Union{Tuple{N2}, Tuple{N1}, Tuple{AbstractArray{#s66,N1} where #s66&lt;:Float64,Float64,AbstractArray{#s65,N2} where #s65&lt;:Float64,Float64}} where N2 where N1"><code>DDD.limits!</code></a></li><li><a href="#DDD.load-Tuple{AbstractString}"><code>DDD.load</code></a></li><li><a href="#DDD.loadDislocationLoop-Tuple{Dict{T1,T2} where T2 where T1,SlipSystem}"><code>DDD.loadDislocationLoop</code></a></li><li><a href="#DDD.loadDislocationP-Union{Tuple{Dict{T1,T2}}, Tuple{T2}, Tuple{T1}} where T2 where T1"><code>DDD.loadDislocationP</code></a></li><li><a href="#DDD.loadIntegrationP-Union{Tuple{Dict{T1,T2}}, Tuple{T2}, Tuple{T1}} where T2 where T1"><code>DDD.loadIntegrationP</code></a></li><li><a href="#DDD.loadMaterialP-Union{Tuple{Dict{T1,T2}}, Tuple{T2}, Tuple{T1}} where T2 where T1"><code>DDD.loadMaterialP</code></a></li><li><a href="#DDD.loadNetwork-Tuple{AbstractString}"><code>DDD.loadNetwork</code></a></li><li><a href="#DDD.loadParams-NTuple{5,AbstractString}"><code>DDD.loadParams</code></a></li><li><a href="#DDD.loadSlipSystem-Union{Tuple{Dict{T1,T2}}, Tuple{T2}, Tuple{T1}} where T2 where T1"><code>DDD.loadSlipSystem</code></a></li><li><a href="#DDD.loopDistribution-Tuple{Zeros,Integer,Vararg{Any,N} where N}"><code>DDD.loopDistribution</code></a></li><li><a href="#DDD.makeConnect!-Tuple{DislocationNetwork}"><code>DDD.makeConnect!</code></a></li><li><a href="#DDD.makeInstanceDict-Tuple{DataType}"><code>DDD.makeInstanceDict</code></a></li><li><a href="#DDD.makeLoop-Union{Tuple{T8}, Tuple{T7}, Tuple{T6}, Tuple{T5}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1,T2,T2,T2,T3,T2,T4,T4,T5,T6,T7,T8}} where T8&lt;:AbstractDistribution where T7&lt;:(AbstractArray{#s61,N} where #s61&lt;:Float64 where N) where T6&lt;:Float64 where T5&lt;:Array{nodeType,1} where T4&lt;:(AbstractArray{#s62,N} where #s62&lt;:Float64 where N) where T3&lt;:Union{Float64, AbstractArray{#s63,N} where #s63&lt;:Float64 where N} where T2&lt;:Int64 where T1&lt;:AbstractDlnStr"><code>DDD.makeLoop</code></a></li><li><a href="#DDD.makeNetwork"><code>DDD.makeNetwork</code></a></li><li><a href="#DDD.makeNetwork!"><code>DDD.makeNetwork!</code></a></li><li><a href="#DDD.makeSegment-Union{Tuple{T}, Tuple{DDD.segEdge,Array{T,1},Array{T,1}}} where T&lt;:Float64"><code>DDD.makeSegment</code></a></li><li><a href="#DDD.makeTypeDict-Tuple{DataType}"><code>DDD.makeTypeDict</code></a></li><li><a href="#DDD.pkForce-Tuple{DDD.DislocationFEMCorrective,DDD.RegularCuboidMesh,AbstractArray{#s69,N} where #s69&lt;:Float64 where N}"><code>DDD.pkForce</code></a></li><li><a href="#DDD.rot3D-Tuple{AbstractArray{#s13,1} where #s13&lt;:Real,AbstractArray{#s12,1} where #s12&lt;:Real,AbstractArray{#s39,1} where #s39&lt;:Real,Real}"><code>DDD.rot3D</code></a></li><li><a href="#DDD.save-Tuple{AbstractString,Vararg{Any,N} where N}"><code>DDD.save</code></a></li><li><a href="#DDD.shapeFunction-Tuple{LinearQuadrangle3D,Float64,Float64,Float64}"><code>DDD.shapeFunction</code></a></li><li><a href="#DDD.shapeFunctionDeriv-Tuple{LinearQuadrangle3D,Float64,Float64,Float64}"><code>DDD.shapeFunctionDeriv</code></a></li><li><a href="#DDD.subTypeTree-Tuple{Any}"><code>DDD.subTypeTree</code></a></li><li><a href="#DDD.translateEnum-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{DataType,Dict{T1,T2},T3}} where T3 where T2 where T1"><code>DDD.translateEnum</code></a></li><li><a href="#DDD.translatePoints-Union{Tuple{N2}, Tuple{N1}, Tuple{AbstractArray{#s65,N1} where #s65&lt;:Float64,AbstractArray{#s64,N1} where #s64&lt;:Float64,AbstractArray{#s63,N2} where #s63&lt;:Float64}} where N2 where N1"><code>DDD.translatePoints</code></a></li><li><a href="#JSON.Writer.lower-Union{Tuple{T}, Tuple{T}} where T&lt;:Union{DDD.AbstractCrystalStruct, AbstractDistribution, DDD.AbstractDlnSeg, AbstractDlnStr, DDD.AbstractIntegrator, DDD.AbstractMobility}"><code>JSON.Writer.lower</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="DDD.AbstractDistribution" href="#DDD.AbstractDistribution"><code>DDD.AbstractDistribution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractDistribution end
struct Zeros &lt;: AbstractDistribution end
struct Rand &lt;: AbstractDistribution end
struct Randn &lt;: AbstractDistribution end
struct Regular &lt;: AbstractDistribution end</code></pre><p>Distributions for dislocation sources.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/Dislocation/DislocationType.jl#LL57-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.AbstractDlnStr" href="#DDD.AbstractDlnStr"><code>DDD.AbstractDlnStr</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Dislocation structures have different classifications. Prismatic loops are made up only of edge segments with the same slip system; shear loops are made up of a mixture of segment types with the same slip system; jogs and kinks are steps not contained in the slip plane.</p><pre><code class="language-none">abstract type AbstractDlnStr end
struct loopDln &lt;: AbstractDlnStr end    # Unclassified loop.
struct loopPrism &lt;: AbstractDlnStr end  # Prismatic loop.
struct loopShear &lt;: AbstractDlnStr end  # Shear loop.
struct loopJog &lt;: AbstractDlnStr end    # Jog.
struct loopKink &lt;: AbstractDlnStr end   # Kink.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/Dislocation/DislocationType.jl#LL39-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.DislocationLoop" href="#DDD.DislocationLoop"><code>DDD.DislocationLoop</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct DislocationLoop{
    T1 &lt;: AbstractDlnStr,
    T2 &lt;: Int64,
    T3 &lt;: Union{T where {T &lt;: Float64}, AbstractArray{&lt;:Float64, N} where {N}},
    T4 &lt;: Union{T where {T &lt;: Int64}, AbstractArray{&lt;:Int64, N} where {N}},
    T5 &lt;: AbstractArray{&lt;:Int64, N} where {N},
    T6 &lt;: AbstractArray{&lt;:Float64, N} where {N},
    T7 &lt;: Vector{&lt;:nodeType},
    T8 &lt;: Float64,
    T9 &lt;: AbstractDistribution,
}

    loopType::T1
    numSides::T2
    nodeSide::T2
    numLoops::T2
    segLen::T3
    slipSystem::T4
    links::T5
    slipPlane::T6
    bVec::T6
    coord::T6
    label::T7
    buffer::T8
    range::T6
    dist::T9</code></pre><p>Dislocation loop structure generated via the constructor <a href="#DDD.makeLoop-Union{Tuple{T8}, Tuple{T7}, Tuple{T6}, Tuple{T5}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1,T2,T2,T2,T3,T2,T4,T4,T5,T6,T7,T8}} where T8&lt;:AbstractDistribution where T7&lt;:(AbstractArray{#s61,N} where #s61&lt;:Float64 where N) where T6&lt;:Float64 where T5&lt;:Array{nodeType,1} where T4&lt;:(AbstractArray{#s62,N} where #s62&lt;:Float64 where N) where T3&lt;:Union{Float64, AbstractArray{#s63,N} where #s63&lt;:Float64 where N} where T2&lt;:Int64 where T1&lt;:AbstractDlnStr"><code>makeLoop</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/Dislocation/DislocationType.jl#LL218-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.DislocationNetwork" href="#DDD.DislocationNetwork"><code>DDD.DislocationNetwork</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DislocationNetwork{
    T1 &lt;: AbstractArray{&lt;:Int64, N} where {N},
    T2 &lt;: AbstractArray{&lt;:Float64, N} where {N},
    T3 &lt;: Vector{nodeType},
    T4 &lt;: Int64,
    T5 &lt;: Integer,
}
    links::T1
    slipPlane::T2
    bVec::T2
    coord::T2
    label::T3
    numNode::T4 = 0     # Total number of nodes in network.
    numSeg::T4 = 0      # Total number of segs in network.
    maxConnect::T5 = 4  # Maximum connectivity of nodes.
    connectivity::T1
    linksConnect::T1
    segIdx::T1          # segIdx[:,1] is the segment index. Used to find the bVec and slipPlane of a real segment. segIdx[:,2:3] are the indices of the nodes involved in a given link, used to find their coordinates.</code></pre><p>Dislocation Network structure. See <a href="#DDD.DislocationLoop"><code>DislocationLoop</code></a>, <a href="#DDD.makeNetwork"><code>makeNetwork</code></a> and <a href="#DDD.makeNetwork!"><code>makeNetwork!</code></a> for further details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/Dislocation/DislocationType.jl#LL347-L369">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.SlipSystem" href="#DDD.SlipSystem"><code>DDD.SlipSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct SlipSystem{
    T1 &lt;: AbstractString,
    T2 &lt;: AbstractArray{&lt;:Float64, N} where {N},
}
    name::T1
    slipPlane::T2
    bVec::T2</code></pre><p>Slip systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/Dislocation/DislocationType.jl#LL85-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.nodeType" href="#DDD.nodeType"><code>DDD.nodeType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Dislocation nodes have labels that change how they are treated by the simulation. There are only given types of nodes so these labels may only take on predefined values and error for anything else.</p><pre><code class="language-none">@enum nodeType begin
    undef = -1  # Undefined node, value at initialisation.
    intMob = 0  # Internal mobile node.
    intFix = 1  # Internal fixed node.
    srfMob = 2  # Mobile surface node.
    srfFix = 3  # Fixed surface node.
    ext = 4     # External node.
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/#L0-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.calcSegSegForce-Tuple{DDD.DislocationP,DDD.MaterialP,DislocationNetwork}" href="#DDD.calcSegSegForce-Tuple{DDD.DislocationP,DDD.MaterialP,DislocationNetwork}"><code>DDD.calcSegSegForce</code></a> — <span class="docstring-category">Method</span></header><section><div><p>!!! Note     This function is based on the SegSegForces function by A. Arsenlis et al. It is optimised for speed and reusability.</p><pre><code class="language-none"></code></pre><p>It implements the analytical solution of the force between two dislocation segments. Details are found in Appendix A.1. in <a href="https://doi.org/10.1088%2F0965-0393%2F15%2F6%2F001">&quot;Enabling Strain Hardening Simulations with Dislocation Dynamics&quot; by A. Arsenlis et al.</a></p><p>At a high level this works by creating a local coordinate frame using the line directions of the dislocation segments and a vector orthogonal to them. The line integrals are then evaluated parametrically utilising this local coordinate. BibTex citation here:</p><p>@article{Arsenlis_2007, 	doi = {10.1088/0965-0393/15/6/001}, 	url = {https://doi.org/10.1088%2F0965-0393%2F15%2F6%2F001}, 	year = 2007, 	month = {jul}, 	publisher = {{IOP} Publishing}, 	volume = {15}, 	number = {6}, 	pages = {553–595}, 	author = {A Arsenlis and W Cai and M Tang and M Rhee and T Oppelstrup and G Hommes and T G Pierce and V V Bulatov}, 	title = {Enabling strain hardening simulations with dislocation dynamics}, 	journal = {Modelling and Simulation in Materials Science and Engineering}, 	abstract = {Numerical algorithms for discrete dislocation dynamics simulations are investigated for the purpose of enabling strain hardening simulations of single crystals on massively parallel computers. The algorithms investigated include the calculation of forces, the equations of motion, time integration, adaptive mesh refinement, the treatment of dislocation core reactions and the dynamic distribution of data and work on parallel computers. A simulation integrating all these algorithmic elements using the Parallel Dislocation Simulator (ParaDiS) code is performed to understand their behaviour in concert and to evaluate the overall numerical performance of dislocation dynamics simulations and their ability to accumulate percent of plastic strain.} }</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/Dislocation/DislocationFunctions.jl#LL100-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.calcSelfForce-Tuple{DDD.DislocationP,DDD.MaterialP,DislocationNetwork}" href="#DDD.calcSelfForce-Tuple{DDD.DislocationP,DDD.MaterialP,DislocationNetwork}"><code>DDD.calcSelfForce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function calcSelfForce(
    dlnParams::DislocationP,
    matParams::MaterialP,
    network::DislocationNetwork,
)</code></pre><p>Calculates the self-interaction force felt by two nodes in a segment. Naturally the forces are equal and opposite to each other.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/Dislocation/DislocationFunctions.jl#LL1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.checkNetwork-Tuple{DislocationNetwork}" href="#DDD.checkNetwork-Tuple{DislocationNetwork}"><code>DDD.checkNetwork</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">checkNetwork(network::DislocationNetwork)</code></pre><p>Checks the validity of the dislocation network. It ensures the following conditions are met by the member variables of <code>network</code>:</p><ol><li><code>connectivity</code> and <code>links</code> have the same number of non-zero entries;</li><li>all entries in <code>bVec</code> are non-zero;</li><li>only the trailing columns of <code>connectivity</code> are zeros;</li><li>consistency between <code>connectivity</code> and <code>links</code>;</li><li><code>bVec</code> is conserved among connected nodes;</li><li>entries in <code>links</code> are unique;</li><li>consistency betwen <code>connectivity</code> and <code>linksConnect</code></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/Dislocation/DislocationTypeConstructors.jl#LL453-L466">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.compStruct-Tuple{Any,Any}" href="#DDD.compStruct-Tuple{Any,Any}"><code>DDD.compStruct</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compStruct(arg1, arg2; verbose::Bool=false)</code></pre><p>Function that compares values of the fields of two variables <code>arg1</code> and <code>arg2</code> with the same structure. If <code>verbose = true</code>, it will print which fields are different from each other.</p><p><strong>Examples</strong></p><pre><code class="language-">julia&gt; struct MyStruct1; x; end
julia&gt; test1 = MyStruct1(1)
MyStruct1(1)
julia&gt; test2 = MyStruct1(5)
MyStruct1(5)
julia&gt; compStruct(test1, test2; verbose = true)
Structures differ in field: x.
false
julia&gt; compStruct(1, 1; verbose = true)
true
julia&gt; compStruct(1, [1]; verbose = true)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/Misc/Misc.jl#LL111-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.extAngle-Tuple{Int64}" href="#DDD.extAngle-Tuple{Int64}"><code>DDD.extAngle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">extAngle(n::Int64)</code></pre><p>Calculates the exterior angle of a regular polygon with <code>n</code> sides.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/Misc/Misc.jl#LL161-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.intAngle-Tuple{Int64}" href="#DDD.intAngle-Tuple{Int64}"><code>DDD.intAngle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">intAngle(n::Int64)</code></pre><p>Calculates the interior angle of a regular polygon with <code>n</code> sides.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/Misc/Misc.jl#LL151-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.load-Tuple{AbstractString}" href="#DDD.load-Tuple{AbstractString}"><code>DDD.load</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">load(filename::AbstractString)</code></pre><p>Wrapper for <code>JSON.parsefile(filename)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/IO/Input.jl#LL1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.loadDislocationLoop-Tuple{Dict{T1,T2} where T2 where T1,SlipSystem}" href="#DDD.loadDislocationLoop-Tuple{Dict{T1,T2} where T2 where T1,SlipSystem}"><code>DDD.loadDislocationLoop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function loadDislocationLoop(
    dict::Dict{T1, T2} where {T1, T2},
    slipSystem::SlipSystem,
)</code></pre><p>Loads initial dislocation structure out of a dictionary loaded from a JSON file. Returns a variable of type <a href="#DDD.DislocationLoop"><code>DislocationLoop</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/IO/Input.jl#LL12-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.loadDislocationP-Union{Tuple{Dict{T1,T2}}, Tuple{T2}, Tuple{T1}} where T2 where T1" href="#DDD.loadDislocationP-Union{Tuple{Dict{T1,T2}}, Tuple{T2}, Tuple{T1}} where T2 where T1"><code>DDD.loadDislocationP</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">loadDislocationP(dict::Dict{T1, T2}) where {T1, T2}</code></pre><p>Loads dislocation parameters out of a dictionary loaded from a JSON file. Returns a variable of type <a href="#DDD.DislocationP"><code>DislocationP</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/IO/Input.jl#LL125-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.loadIntegrationP-Union{Tuple{Dict{T1,T2}}, Tuple{T2}, Tuple{T1}} where T2 where T1" href="#DDD.loadIntegrationP-Union{Tuple{Dict{T1,T2}}, Tuple{T2}, Tuple{T1}} where T2 where T1"><code>DDD.loadIntegrationP</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">loadIntegrationP(dict::Dict{T1, T2}) where {T1, T2}</code></pre><p>Loads integration parameters out of a dictionary loaded from a JSON file. Returns a variable of type <a href="#DDD.IntegrationP"><code>IntegrationP</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/IO/Input.jl#LL76-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.loadMaterialP-Union{Tuple{Dict{T1,T2}}, Tuple{T2}, Tuple{T1}} where T2 where T1" href="#DDD.loadMaterialP-Union{Tuple{Dict{T1,T2}}, Tuple{T2}, Tuple{T1}} where T2 where T1"><code>DDD.loadMaterialP</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">loadMaterialP(dict::Dict{T1, T2}) where {T1, T2}</code></pre><p>Loads material parameters out of a dictionary loaded from a JSON file. Returns a variable of type <a href="#DDD.MaterialP"><code>MaterialP</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/IO/Input.jl#LL55-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.loadNetwork-Tuple{AbstractString}" href="#DDD.loadNetwork-Tuple{AbstractString}"><code>DDD.loadNetwork</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">loadNetwork(fileDislocationNetwork::AbstractString)</code></pre><p>Loads a dislocation network from a JSON file. Returns a <a href="#DDD.DislocationNetwork"><code>DislocationNetwork</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/IO/Input.jl#LL199-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.loadParams-NTuple{5,AbstractString}" href="#DDD.loadParams-NTuple{5,AbstractString}"><code>DDD.loadParams</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">loadParams(
    fileDislocationP::AbstractString,
    fileMaterialP::AbstractString,
    fileIntegrationP::AbstractString,
    fileSlipSystem::AbstractString,
    fileDislocationLoop::AbstractString,
)</code></pre><p>Loads simulation parameters out of a dictionary loaded from a JSON file. Returns a tuple of variable types (<a href="#DDD.DislocationP"><code>DislocationP</code></a>, <a href="#DDD.MaterialP"><code>MaterialP</code></a>, <a href="#DDD.IntegrationP"><code>IntegrationP</code></a>, <a href="#DDD.SlipSystem"><code>SlipSystem</code></a>, <a href="#DDD.DislocationLoop"><code>DislocationLoop</code></a>) or vectors of those types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/IO/Input.jl#LL157-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.loadSlipSystem-Union{Tuple{Dict{T1,T2}}, Tuple{T2}, Tuple{T1}} where T2 where T1" href="#DDD.loadSlipSystem-Union{Tuple{Dict{T1,T2}}, Tuple{T2}, Tuple{T1}} where T2 where T1"><code>DDD.loadSlipSystem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">loadSlipSystem(dict::Dict{T1, T2}) where {T1, T2}</code></pre><p>Loads slip systems out of a dictionary loaded from a JSON file. Returns a variable of type <a href="#DDD.SlipSystem"><code>SlipSystem</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/IO/Input.jl#LL100-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.loopDistribution-Tuple{Zeros,Integer,Vararg{Any,N} where N}" href="#DDD.loopDistribution-Tuple{Zeros,Integer,Vararg{Any,N} where N}"><code>DDD.loopDistribution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">loopDistribution(dist&lt;:AbstractDistribution, n::Integer, args...; kw...)</code></pre><p>Returns <code>n</code> points according to the concrete subtype of <a href="#DDD.AbstractDistribution"><code>AbstractDistribution</code></a> given. Overload this function with new concrete subtypes and custom distributions. This and <a href="#DDD.limits!-Union{Tuple{N2}, Tuple{N1}, Tuple{AbstractArray{#s66,N1} where #s66&lt;:Float64,Float64,AbstractArray{#s65,N2} where #s65&lt;:Float64,Float64}} where N2 where N1"><code>limits!</code></a> are used in <a href="#DDD.translatePoints-Union{Tuple{N2}, Tuple{N1}, Tuple{AbstractArray{#s65,N1} where #s65&lt;:Float64,AbstractArray{#s64,N1} where #s64&lt;:Float64,AbstractArray{#s63,N2} where #s63&lt;:Float64}} where N2 where N1"><code>translatePoints</code></a> to distribute dislocations in the simulation domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/Dislocation/DislocationTypeConstructors.jl#LL347-L352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.makeNetwork" href="#DDD.makeNetwork"><code>DDD.makeNetwork</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">makeNetwork(
    sources::Union{
            DislocationLoop,
            AbstractVector{&lt;:DislocationLoop}
        }, # Dislocation structures.
    maxConnect::Integer = 4,
    memBuffer::Integer = 10, # Buffer for memory allocation. The code will allocate the total number of nodes times `memBuffer` to reduce dynamic memory allocation during runtime.
    args...;
    checkConsistency::Bool = false, # Check the consistency of the network.
    kw...,
)</code></pre><p>Constructor for <a href="#DDD.DislocationNetwork"><code>DislocationNetwork</code></a>, see <a href="#DDD.makeNetwork!"><code>makeNetwork!</code></a> for in-place version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/Dislocation/DislocationTypeConstructors.jl#LL173-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.makeNetwork!" href="#DDD.makeNetwork!"><code>DDD.makeNetwork!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">makeNetwork!(
    network::DislocationNetwork,
    sources::Union{
        DislocationLoop,
        AbstractVector{&lt;:DislocationLoop}
    },
    maxConnect::Integer = 4,
    args...;
    checkConsistency::Bool = false,
    kw...,
)</code></pre><p>In-place constructor for <a href="#DDD.DislocationNetwork"><code>DislocationNetwork</code></a>, see <a href="#DDD.makeNetwork"><code>makeNetwork</code></a> for constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/Dislocation/DislocationTypeConstructors.jl#LL262-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.makeTypeDict-Tuple{DataType}" href="#DDD.makeTypeDict-Tuple{DataType}"><code>DDD.makeTypeDict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function makeTypeDict(valType::DataType)</code></pre><p>Inputs contain strings that correspond to DDD data types. This function atuomatically creates a dictionary for all concrete subtypes of a given <code>valType</code>.</p><p><strong>Examples</strong></p><pre><code class="language-">julia&gt; abstract type MyAbstractType end
julia&gt; struct MyStruct1 &lt;: MyAbstractType end
julia&gt; struct MyStruct2 &lt;: MyAbstractType end
julia&gt; makeTypeDict(MyAbstractType)
Dict{String,Any} with 4 entries:
  &quot;DDD.MyStruct1()&quot; =&gt; MyStruct1()
  &quot;DDD.MyStruct2()&quot; =&gt; MyStruct2()
  &quot;MyStruct1()&quot;     =&gt; MyStruct1()
  &quot;MyStruct2()&quot;     =&gt; MyStruct2()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/Misc/Misc.jl#LL52-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.rot3D-Tuple{AbstractArray{#s13,1} where #s13&lt;:Real,AbstractArray{#s12,1} where #s12&lt;:Real,AbstractArray{#s39,1} where #s39&lt;:Real,Real}" href="#DDD.rot3D-Tuple{AbstractArray{#s13,1} where #s13&lt;:Real,AbstractArray{#s12,1} where #s12&lt;:Real,AbstractArray{#s39,1} where #s39&lt;:Real,Real}"><code>DDD.rot3D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rot3D(xyz::Vector{&lt;:Real}, uvw::Vector{&lt;:Real}, abc::Vector{&lt;:Real},
    θ::Real)</code></pre><p>Rotate point <code>xyz</code> about the line with direction vector <code>uvw</code> that crosses the point <code>abc</code> by the angle <code>θ</code>. Further details found <a href="https://sites.google.com/site/glennmurray/Home/rotation-matrices-and-formulas/rotation-about-an-arbitrary-axis-in-3-dimensions">here</a>.</p><p><strong>Examples</strong></p><pre><code class="language-">julia&gt; rot3D([1;1;1],[1;0;0],[0;0;0],π/2)
3-element Array{Float64,1}:
  1.0
 -0.9999999999999999
  1.0
julia&gt; rot3D([1;1;1],[1;0;0],[0;0;0],-π/2)
3-element Array{Float64,1}:
1.0
1.0
-0.9999999999999999
julia&gt; rot3D([1;1;1],[1;0;0],[0;0;0],π)
3-element Array{Float64,1}:
  1.0
 -1.0000000000000002
 -0.9999999999999999</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/Misc/Misc.jl#LL171-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.save-Tuple{AbstractString,Vararg{Any,N} where N}" href="#DDD.save-Tuple{AbstractString,Vararg{Any,N} where N}"><code>DDD.save</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">save(filename::AbstractString, args...; mode::AbstractString = &quot;w&quot;)</code></pre><p>Wrapper for <code>JSON.print</code> to a file, <code>args</code> are the variables or structures you want to save.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/IO/Output.jl#LL34-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.shapeFunction-Tuple{LinearQuadrangle3D,Float64,Float64,Float64}" href="#DDD.shapeFunction-Tuple{LinearQuadrangle3D,Float64,Float64,Float64}"><code>DDD.shapeFunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">shapeFunction(
    shape&lt;:AbstractShapeFunction,
    x::Union{Float64, AbstractVector{&lt;:Float64}},
    y::Union{Float64, AbstractVector{&lt;:Float64}},
    z::Union{Float64, AbstractVector{&lt;:Float64}}</code></pre><p>Returns the shape functions of type <code>typeof(shape) &lt;: AbstractShapeFunction</code>. If <code>x,y,z</code> are floats returns a vector of length <code>N</code>, different shape functons have different numbers of nodes. If given vectors, returns an array of size <code>(N, length(x))</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>All coordinate vectors must be of equal length.</p></div></div><p><a href="#DDD.shapeFunctionDeriv-Tuple{LinearQuadrangle3D,Float64,Float64,Float64}"><code>shapeFunctionDeriv</code></a> are the 1st order derivatives of the shape functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/FEM/FEMFunctions.jl#LL1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.shapeFunctionDeriv-Tuple{LinearQuadrangle3D,Float64,Float64,Float64}" href="#DDD.shapeFunctionDeriv-Tuple{LinearQuadrangle3D,Float64,Float64,Float64}"><code>DDD.shapeFunctionDeriv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">shapeFunctionDeriv(
    shape&lt;:AbstractShapeFunction,
    x::Union{Float64, AbstractVector{&lt;:Float64}},
    y::Union{Float64, AbstractVector{&lt;:Float64}},
    z::Union{Float64, AbstractVector{&lt;:Float64}}</code></pre><p>Returns the first order derivative of the shape functions, <a href="#DDD.shapeFunction-Tuple{LinearQuadrangle3D,Float64,Float64,Float64}"><code>shapeFunction</code></a>, of type <code>typeof(shape) &lt;: AbstractShapeFunction</code>. If <code>x,y,z</code> are floats returns a 2D array of size <code>(N, 3)</code>. If given vectors, returns a 3D array of size <code>(N, 3, length(x))</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>All coordinate vectors must be of equal length.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/FEM/FEMFunctions.jl#LL80-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.AbstractCrystalStruct" href="#DDD.AbstractCrystalStruct"><code>DDD.AbstractCrystalStruct</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractCrystalStruct end
struct BCC &lt;: AbstractCrystalStruct end
struct FCC &lt;: AbstractCrystalStruct end
struct HCP &lt;: AbstractCrystalStruct end</code></pre><p>Crystal structures.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/Material/MaterialType.jl#LL1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.AbstractDlnSeg" href="#DDD.AbstractDlnSeg"><code>DDD.AbstractDlnSeg</code></a> — <span class="docstring-category">Type</span></header><section><div><p>There are different types of segments. Edge segments are orthogonal to the Burgers vector; screw segments are parallel to the Burgers vector; mixed segments are anything in between. Segment type can be easily inferred during runtime. These are mainly used for multiple dispatch purposes.</p><pre><code class="language-none">abstract type AbstractDlnSeg end
struct segNone &lt;: AbstractDlnSeg end    # Undefined segment.
struct segEdge &lt;: AbstractDlnSeg end    # Edge segment.
struct segEdgeN &lt;: AbstractDlnSeg end   # Edge segment parallel to slip plane.
struct segScrew &lt;: AbstractDlnSeg end   # Screw segment.
struct segMixed &lt;: AbstractDlnSeg end   # Mixed segment.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/Dislocation/DislocationType.jl#LL22-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.AbstractIntegrator" href="#DDD.AbstractIntegrator"><code>DDD.AbstractIntegrator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractIntegrator end
struct CustomTrapezoid &lt;:AbstractIntegrator end</code></pre><p>Integrator types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/Integration/CustomIntegration.jl#LL1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.AbstractMesh" href="#DDD.AbstractMesh"><code>DDD.AbstractMesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractMesh end</code></pre><p>Abstract mesh type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/FEM/FEMType.jl#LL1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.AbstractMobility" href="#DDD.AbstractMobility"><code>DDD.AbstractMobility</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractMobility end
struct BCC &lt;: AbstractMobility end
struct FCC &lt;: AbstractMobility end
struct HCP &lt;: AbstractMobility end</code></pre><p>Mobility functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/Dislocation/DislocationType.jl#LL72-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.AbstractShapeFunction" href="#DDD.AbstractShapeFunction"><code>DDD.AbstractShapeFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractShapeFunction end
abstract type AbstractShapeFunction3D &lt;: AbstractShapeFunction end
abstract type AbstractShapeFunction2D &lt;: AbstractShapeFunction end
struct LinearQuadrangle3D &lt;:AbstractShapeFunction3D end
struct LinearQuadrangle2D &lt;:AbstractShapeFunction2D end</code></pre><p>Abstract types for different shape functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/FEM/FEMType.jl#LL9-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.DislocationP" href="#DDD.DislocationP"><code>DDD.DislocationP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DislocationP{
    T1 &lt;: Float64,
    T2 &lt;: Int64,
    T3 &lt;: Bool,
    T4 &lt;: AbstractMobility,
}
    # Size.
    coreRad::T1     # Core radius.
    coreRadMag::T1  # Magnitude of core Radius.
    # Connectivity.
    minSegLen::T1       # Minimum line length.
    maxSegLen::T1       # Maximum line length.
    minArea::T1         # Minimum area for remeshing.
    maxArea::T1         # Maximum area for remeshing.
    maxConnect::T2      # Maximum number of connections to a node.
    remesh::T3          # Flag for remeshing.
    collision::T3       # Flag for collision handling.
    separation::T3      # Flag for separation handling.
    virtualRemesh::T3   # Flag for virtual remeshing.
    # Mobility.
    edgeDrag::T1    # Drag coefficient edge dislocation.
    screwDrag::T1   # Drag coefficient screw dislocation.
    climbDrag::T1   # Drag coefficient climb.
    lineDrag::T1    # Drag coefficient line.
    mobility::T4    # Mobility law.</code></pre><p>Dislocation parameters structure. See <a href="#DDD.AbstractMobility"><code>AbstractMobility</code></a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/Dislocation/DislocationType.jl#LL113-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.IntegrationP" href="#DDD.IntegrationP"><code>DDD.IntegrationP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IntegrationP{
    T1 &lt;: Float64,
    T2 &lt;: AbstractIntegrator,
    T3 &lt;: Int64,
}
    dt::T1
    tmin::T1
    tmax::T1
    method::T2
    abstol::T1
    reltol::T1
    time::T1
    step::T3</code></pre><p>This structure contains the integration parameters for the simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/Integration/CustomIntegration.jl#LL11-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.MaterialP" href="#DDD.MaterialP"><code>DDD.MaterialP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MaterialP{T1 &lt;: Float64, T2 &lt;: AbstractCrystalStruct}
    μ::T1
    μMag::T1
    ν::T1
    E::T1
    crystalStruct::T2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/Material/MaterialType.jl#LL14-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.coordIdx-Union{Tuple{N}, Tuple{DislocationNetwork,Union{Integer, AbstractArray{#s69,N} where #s69&lt;:Integer}}} where N" href="#DDD.coordIdx-Union{Tuple{N}, Tuple{DislocationNetwork,Union{Integer, AbstractArray{#s69,N} where #s69&lt;:Integer}}} where N"><code>DDD.coordIdx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">coordIdx(network::DislocationNetwork,
    index::Union{Integer,AbstractArray{&lt;:Integer, N}) where {N}</code></pre><p>Get coordinates for the node(s) that with the <code>index</code> or vector of indices provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/Dislocation/DislocationIdx.jl#LL43-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.coordLbl-Tuple{DislocationNetwork,Integer}" href="#DDD.coordLbl-Tuple{DislocationNetwork,Integer}"><code>DDD.coordLbl</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Related functions: <a href="#DDD.idxLabel-Tuple{DislocationNetwork,Integer}"><code>idxLabel</code></a></p><pre><code class="language-none">coordLbl(network::DislocationNetwork, label::Integer)</code></pre><p>Get coordinates for the nodes with a given label (node type).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/Dislocation/DislocationIdx.jl#LL33-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.dataCond-Tuple{DislocationNetwork,Symbol,Real}" href="#DDD.dataCond-Tuple{DislocationNetwork,Symbol,Real}"><code>DDD.dataCond</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Related functions: <code>idxCond</code></p><pre><code class="language-none">dataCond(network::DislocationNetwork, dataField::Symbol, val::Real;
    condition::Function = ==)</code></pre><p>Get the data whose <code>dataField</code>, <code>(:links, :bVec, :slipPlane, :coord, :label, :numNode, :numSeg)</code>, meets the <code>condition(dataField, val)</code>. If <code>dataField</code> is multidimensional it will use <code>CartesianIndex</code> to find it.</p><pre><code class="language-none">dataCond(network::DislocationNetwork, dataField::Symbol, idxComp::Integer,
    val::Real; condition::Function = ==)</code></pre><p>Get the data whose <code>dataField</code>, meets the <code>condition(dataField[:,idxComp], val)</code>. It errors if the fieldname provided does not have a column <code>idxComp</code>.</p><pre><code class="language-none">dataCond(network::DislocationNetwork, dataField::Symbol, condField::Symbol,
    val::Real; condition::Function = ==)</code></pre><p>Get the data from <code>dataField</code> that corresponds to the <code>condField</code> (from the same pool as <code>dataField</code>) that meets the <code>condition(condField, val)</code>. If <code>condField</code> is multidimensional it will use <code>CartesianIndex</code> in its search. <code>dataField</code> and <code>condField</code> must have the same number of rows.</p><pre><code class="language-none">dataCond(network::DislocationNetwork, dataField::Symbol, condField::Symbol,
    idxComp::Integer, val::Real; condition::Function = ==)</code></pre><p>Get the data from <code>dataField</code> that corresponds to the <code>condField</code> that meets the <code>condition(condField[:, idxComp], val)</code>. <code>dataField</code> and <code>condField</code> must have the same number of rows.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/Dislocation/DislocationIdx.jl#LL118-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.hatStress-Tuple{DDD.RegularCuboidMesh,DDD.DislocationFEMCorrective,AbstractArray{#s68,N} where #s68&lt;:Float64 where N}" href="#DDD.hatStress-Tuple{DDD.RegularCuboidMesh,DDD.DislocationFEMCorrective,AbstractArray{#s68,N} where #s68&lt;:Float64 where N}"><code>DDD.hatStress</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"></code></pre><p>Calculate the reaction from a dislocation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/DislocationFEM/DislocationFEMFunctions.jl#LL12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.idxCond-Tuple{DislocationNetwork,Symbol,Function,Vararg{Any,N} where N}" href="#DDD.idxCond-Tuple{DislocationNetwork,Symbol,Function,Vararg{Any,N} where N}"><code>DDD.idxCond</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Related functions: <a href="#DDD.dataCond-Tuple{DislocationNetwork,Symbol,Real}"><code>dataCond</code></a></p><pre><code class="language-none">idxCond(network::DislocationNetwork, fieldname::Symbol,
    args...; condition::Function)</code></pre><p>Find index/indices whose <code>fieldname</code> meets the <code>condition(fieldname, args...)</code> where condition can be any function that uses <code>fieldname</code> and <code>args</code> to make a comparison.</p><pre><code class="language-none">idxCond(data::Union{
        AbstractArray{&lt;:Real,N1},
        AbstractArray{&lt;:nodeType, {N2}}
    },
    val::Real; condition::Function = ==) where {N1,N2}</code></pre><p>Find index/indices of data that meet the condition(data, val).</p><pre><code class="language-none">idxCond(network::DislocationNetwork, fieldname::Symbol, val::Real;
    condition::Function = ==)</code></pre><p>Find index/indices of node whose <code>fieldname</code>, <code>(:links, :bVec, :slipPlane, :coord, :label, :numNode, :numSeg)</code>, meets <code>condition(fieldname, val)</code>. If <code>fieldName</code> is multidimensional it will return <code>CartesianIndex</code>.</p><pre><code class="language-none">idxCond(network::DislocationNetwork, fieldname::Symbol, idxComp::Integer,
    val::Real; condition::Function = ==)</code></pre><p>Find index/indices of node whose <code>fieldname</code> meets <code>condition(fieldname[:, idxComp], val)</code>. It errors if the fieldname provided does not have a column <code>idxComp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/Dislocation/DislocationIdx.jl#LL57-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.idxLabel-Tuple{DislocationNetwork,Integer}" href="#DDD.idxLabel-Tuple{DislocationNetwork,Integer}"><code>DDD.idxLabel</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Related functions: <a href="#DDD.coordLbl-Tuple{DislocationNetwork,Integer}"><code>coordLbl</code></a></p><pre><code class="language-none">idxLabel(network::DislocationNetwork, label::Integer; condition::Function = ==)</code></pre><p>Find indices for dislocations whose <code>label</code> meets <code>condition(x, label)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/Dislocation/DislocationIdx.jl#LL19-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.inclusiveComparison-Tuple{Any,Vararg{Any,N} where N}" href="#DDD.inclusiveComparison-Tuple{Any,Vararg{Any,N} where N}"><code>DDD.inclusiveComparison</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inclusiveComparison(data, args...)</code></pre><p>Compare data to a tuple, return <code>true</code> if it is equal to any arg, <code>false</code> if it is not equal to any.</p><p><strong>Examples</strong></p><pre><code class="language-">julia&gt; inclusiveComparison(&quot;f&quot;, 1,4,5,&quot;f&quot;)
true
julia&gt; inclusiveComparison(23.246, 1.5, 4, 5, &quot;f&quot;)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/Misc/Misc.jl#LL87-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.limits!-Union{Tuple{N2}, Tuple{N1}, Tuple{AbstractArray{#s66,N1} where #s66&lt;:Float64,Float64,AbstractArray{#s65,N2} where #s65&lt;:Float64,Float64}} where N2 where N1" href="#DDD.limits!-Union{Tuple{N2}, Tuple{N1}, Tuple{AbstractArray{#s66,N1} where #s66&lt;:Float64,Float64,AbstractArray{#s65,N2} where #s65&lt;:Float64,Float64}} where N2 where N1"><code>DDD.limits!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">limits!(
    lims::AbstractArray{&lt;:Float64, N1},
    segLen::Float64,
    range::AbstractArray{&lt;:Float64, N2},
    buffer::Float64,
) where {N1, N2}</code></pre><p>Calculate the spatial limits a dislocation will occupy. This and <a href="#DDD.loopDistribution-Tuple{Zeros,Integer,Vararg{Any,N} where N}"><code>loopDistribution</code></a> are used in <a href="#DDD.translatePoints-Union{Tuple{N2}, Tuple{N1}, Tuple{AbstractArray{#s65,N1} where #s65&lt;:Float64,AbstractArray{#s64,N1} where #s64&lt;:Float64,AbstractArray{#s63,N2} where #s63&lt;:Float64}} where N2 where N1"><code>translatePoints</code></a> to distribute dislocations in the simulation domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/Dislocation/DislocationTypeConstructors.jl#LL366-L376">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.makeConnect!-Tuple{DislocationNetwork}" href="#DDD.makeConnect!-Tuple{DislocationNetwork}"><code>DDD.makeConnect!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">makeConnect!(network::DislocationNetwork)</code></pre><p>Creates <code>connectivity</code> and <code>linksConnect</code> matrices in-place. <code>connectivity</code> contains the number of other other nodes each node is connected to, up to <code>maxConnect</code> other nodes. It also contains the segments in which it&#39;s involved. <code>linksConnect</code> is the running total of the number of other nodes each node is connected to, will probably be deleted in the future. This is called from <a href="#DDD.makeNetwork"><code>makeNetwork</code></a> and <a href="#DDD.makeNetwork!"><code>makeNetwork!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/Dislocation/DislocationTypeConstructors.jl#LL414-L419">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.makeInstanceDict-Tuple{DataType}" href="#DDD.makeInstanceDict-Tuple{DataType}"><code>DDD.makeInstanceDict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">makeInstanceDict(valType::DataType)</code></pre><p>Make a dictionary of enumerated variable instances. Helps in translating JSON files.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/Misc/Misc.jl#LL1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.makeLoop-Union{Tuple{T8}, Tuple{T7}, Tuple{T6}, Tuple{T5}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1,T2,T2,T2,T3,T2,T4,T4,T5,T6,T7,T8}} where T8&lt;:AbstractDistribution where T7&lt;:(AbstractArray{#s61,N} where #s61&lt;:Float64 where N) where T6&lt;:Float64 where T5&lt;:Array{nodeType,1} where T4&lt;:(AbstractArray{#s62,N} where #s62&lt;:Float64 where N) where T3&lt;:Union{Float64, AbstractArray{#s63,N} where #s63&lt;:Float64 where N} where T2&lt;:Int64 where T1&lt;:AbstractDlnStr" href="#DDD.makeLoop-Union{Tuple{T8}, Tuple{T7}, Tuple{T6}, Tuple{T5}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1,T2,T2,T2,T3,T2,T4,T4,T5,T6,T7,T8}} where T8&lt;:AbstractDistribution where T7&lt;:(AbstractArray{#s61,N} where #s61&lt;:Float64 where N) where T6&lt;:Float64 where T5&lt;:Array{nodeType,1} where T4&lt;:(AbstractArray{#s62,N} where #s62&lt;:Float64 where N) where T3&lt;:Union{Float64, AbstractArray{#s63,N} where #s63&lt;:Float64 where N} where T2&lt;:Int64 where T1&lt;:AbstractDlnStr"><code>DDD.makeLoop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">makeLoop(
    loopType::T1,
    numSides::T2,
    nodeSide::T2,
    numLoops::T2,
    segLen::T3,
    slipSystem::T2,
    _slipPlane::T4,
    _bVec::T4,
    label::T5,
    buffer::T6,
    range::T7,
    dist::T8,
) where {
    T1 &lt;: AbstractDlnStr,
    T2 &lt;: Int64,
    T3 &lt;: Union{T where {T &lt;: Float64}, AbstractArray{&lt;:Float64, N} where {N}},
    T4 &lt;: AbstractArray{&lt;:Float64, N} where {N},
    T5 &lt;: Vector{nodeType},
    T6 &lt;: Float64,
    T7 &lt;: AbstractArray{&lt;:Float64, N} where {N},
    T8 &lt;: AbstractDistribution,
}</code></pre><p>Constructor function for <a href="#DDD.DislocationLoop"><code>DislocationLoop</code></a>. See <a href="#DDD.AbstractDlnStr"><code>AbstractDlnStr</code></a>, <a href="#DDD.AbstractDlnSeg"><code>AbstractDlnSeg</code></a>, <a href="#DDD.nodeType"><code>nodeType</code></a>, <a href="#DDD.AbstractDistribution"><code>AbstractDistribution</code></a> for further details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/Dislocation/DislocationTypeConstructors.jl#LL48-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.makeSegment-Union{Tuple{T}, Tuple{DDD.segEdge,Array{T,1},Array{T,1}}} where T&lt;:Float64" href="#DDD.makeSegment-Union{Tuple{T}, Tuple{DDD.segEdge,Array{T,1},Array{T,1}}} where T&lt;:Float64"><code>DDD.makeSegment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">makeSegment(type::AbstractDlnSeg, slipPlane::Vector{T}, bVec::Vector{T})
    where {T&lt;:Float64}</code></pre><p>Make signle segment depending on the segment type, see <a href="#DDD.AbstractDlnSeg"><code>AbstractDlnSeg</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/Dislocation/DislocationTypeOverloaded.jl#LL13-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.pkForce-Tuple{DDD.DislocationFEMCorrective,DDD.RegularCuboidMesh,AbstractArray{#s69,N} where #s69&lt;:Float64 where N}" href="#DDD.pkForce-Tuple{DDD.DislocationFEMCorrective,DDD.RegularCuboidMesh,AbstractArray{#s69,N} where #s69&lt;:Float64 where N}"><code>DDD.pkForce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"></code></pre><p>Calculate the Peach-Koehler force on segments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/DislocationFEM/DislocationFEMFunctions.jl#LL1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.subTypeTree-Tuple{Any}" href="#DDD.subTypeTree-Tuple{Any}"><code>DDD.subTypeTree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">subTypeTree(t, level = 1, dict = Dict(); cutoff = 0)</code></pre><p>Create subtype dictionary. . Adapted from https://github.com/JuliaLang/julia/issues/24741</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/Misc/Misc.jl#LL38-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.translateEnum-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{DataType,Dict{T1,T2},T3}} where T3 where T2 where T1" href="#DDD.translateEnum-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{DataType,Dict{T1,T2},T3}} where T3 where T2 where T1"><code>DDD.translateEnum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">translateEnum(
    valType::DataType,
    dict::Dict{T1, T2},
    key::T3,
) where {T1, T2, T3}</code></pre><p>Translates the string name of enumerated types to the actual Julia type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/Misc/Misc.jl#LL16-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.translatePoints-Union{Tuple{N2}, Tuple{N1}, Tuple{AbstractArray{#s65,N1} where #s65&lt;:Float64,AbstractArray{#s64,N1} where #s64&lt;:Float64,AbstractArray{#s63,N2} where #s63&lt;:Float64}} where N2 where N1" href="#DDD.translatePoints-Union{Tuple{N2}, Tuple{N1}, Tuple{AbstractArray{#s65,N1} where #s65&lt;:Float64,AbstractArray{#s64,N1} where #s64&lt;:Float64,AbstractArray{#s63,N2} where #s63&lt;:Float64}} where N2 where N1"><code>DDD.translatePoints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function translatePoints(
    coord::AbstractArray{&lt;:Float64, N1},
    lims::AbstractArray{&lt;:Float64, N1},
    disp::AbstractArray{&lt;:Float64, N2},
) where {N1, N2}</code></pre><p>Translate dislocation node coordinates <code>coord</code> inside the spatial bounds of <code>lims</code> (calculated in <a href="#DDD.limits!-Union{Tuple{N2}, Tuple{N1}, Tuple{AbstractArray{#s66,N1} where #s66&lt;:Float64,Float64,AbstractArray{#s65,N2} where #s65&lt;:Float64,Float64}} where N2 where N1"><code>limits!</code></a>) according to the displacement <code>disp</code> (calculated in <a href="#DDD.loopDistribution-Tuple{Zeros,Integer,Vararg{Any,N} where N}"><code>loopDistribution</code></a>). Used to distribute sources inside a domain in <a href="#DDD.makeNetwork"><code>makeNetwork</code></a> and <a href="#DDD.makeNetwork!"><code>makeNetwork!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/Dislocation/DislocationTypeConstructors.jl#LL391-L400">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JSON.Writer.lower-Union{Tuple{T}, Tuple{T}} where T&lt;:Union{DDD.AbstractCrystalStruct, AbstractDistribution, DDD.AbstractDlnSeg, AbstractDlnStr, DDD.AbstractIntegrator, DDD.AbstractMobility}" href="#JSON.Writer.lower-Union{Tuple{T}, Tuple{T}} where T&lt;:Union{DDD.AbstractCrystalStruct, AbstractDistribution, DDD.AbstractDlnSeg, AbstractDlnStr, DDD.AbstractIntegrator, DDD.AbstractMobility}"><code>JSON.Writer.lower</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">JSON.lower(
    t::T,
) where {
    T &lt;: Union{
        AbstractCrystalStruct,
        AbstractMobility,
        AbstractIntegrator,
        AbstractDlnSeg,
        AbstractDlnStr,
        AbstractDistribution,
    },
} = string(t)

JSON.lower(t::nodeType) = Int(t)</code></pre><p>Extensions to <code>JSON.lower</code> for custom types. Allows these variables to be serialised properly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/a2754f22aa1a52bfbaf18d698a390047316ed951/src/IO/Output.jl#LL1-L19">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="types/">Types »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 12 April 2020 06:01">Sunday 12 April 2020</span>. Using Julia version 1.4.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
