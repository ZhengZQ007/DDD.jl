<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · DDD.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href><img src="assets/logo.svg" alt="DDD.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">DDD.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Initialisation-1"><span>Initialisation</span></a></li><li><a class="tocitem" href="#IO-1"><span>IO</span></a></li><li class="toplevel"><a class="tocitem" href="#TODO-1"><span>TODO</span></a></li><li><a class="tocitem" href="#Working-Objectives-1"><span>Working Objectives</span></a></li></ul></li><li><a class="tocitem" href="Dislocations/">Dislocations</a></li><li><a class="tocitem" href="io/">IO</a></li><li><a class="tocitem" href="postProcessing/">Post Processing</a></li><li><a class="tocitem" href="functions/">Functions</a></li><li><a class="tocitem" href="theory/">Discrete Dislocation Dynamics</a></li><li><a class="tocitem" href="motivation/">Motivation</a></li><li><a class="tocitem" href="theory/">Theory</a></li><li><a class="tocitem" href="idx/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/dcelisgarza/DDD.jl/blob/master/docs/src/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Using-DDD.jl-1"><a class="docs-heading-anchor" href="#Using-DDD.jl-1">Using DDD.jl</a><a class="docs-heading-anchor-permalink" href="#Using-DDD.jl-1" title="Permalink"></a></h1><h2 id="Initialisation-1"><a class="docs-heading-anchor" href="#Initialisation-1">Initialisation</a><a class="docs-heading-anchor-permalink" href="#Initialisation-1" title="Permalink"></a></h2><p>Before running a simulation we need to initialise the simulation. For this example, we will use the keyword initialisers because they automatically calculate derived quantities, perform input validations, provide default values, and are make for self-documenting code.</p><p>Dislocations live in a material, as such we need a few constants that describe it. These are encapsulated in the immutable &lt;sup&gt;<a href="#1">1</a>&lt;/sup&gt; structure <code>MaterialP</code>. Note that we use unicode to denote variables as per convention written <code>\mu -&gt; μ</code> and <code>\nu -&gt; ν</code>. Here we create a basic material.</p><pre><code class="language-julia">julia&gt; materialP = MaterialP(;
          μ = 1.0,                  # Shear modulus.
          μMag = 145e3,             # Shear modulus magnitude.
          ν = 0.28,                 # Poisson ratio.
          E = 1.0,                  # Young&#39;s modulus, MPa.
          crystalStruct = BCC(),    # Crystal structure.
          σPN = 0.0                 # Peierls-Nabarro stress for the material.
        )
MaterialP{Float64,BCC}(1.0, 145000.0, 0.28, 1.0, 1.3888888888888888, 0.3888888888888889, 0.07957747154594767, 0.039788735772973836, 0.11052426603603843, BCC(), 0.0)</code></pre><p>Note that a few extra constants have been automatically calculated by the constructor. We find what these correspond to using the <code>fieldnames()</code> on the type of <code>materialP</code>, which is <code>MaterialP</code>.</p><pre><code class="language-julia">julia&gt; fieldnames(typeof(materialP))
(:μ, :μMag, :ν, :E, :σPN, :omνInv, :νomνInv, :μ4π, :μ8π, :μ4πν, :crystalStruct)</code></pre><p>Where <code>omνInv = 1/(1-ν)</code>, <code>νomνInv = v/(1-ν)</code>, <code>μ4π = μ/(4π)</code>, <code>μ8π = μ/(8π)</code>, <code>μ4πν = μ/[4π(1-ν)]</code>. These precomputed variables are used in various places and are there to avoid recalculating them later.</p><p>Our dislocations also have certain constant characteristics that are encapsulated in their own immutable structure, <code>DislocationP</code>. These parameters are somewhat arbitrary as long as they approximately hold certain proportions.</p><pre><code class="language-julia">julia&gt; dislocationP = DislocationP(;
          coreRad = 90.0,       # Dislocation core radius, referred to as a.
          coreRadMag = 3.2e-4,  # Magnitude of the core radius.
          minSegLen = 320.0,    # Minimum segment length.
          maxSegLen = 1600.0,   # Maximum segment length.
          minArea = 45000.0,    # Minimum allowable area enclosed by two segments.
          maxArea = 20*45000.0, # Maximum allowable area enclosed by two segments.
          maxConnect = 4,       # Maximum number of connections a node can have.
          remesh = true,        # Flag for remeshing.
          collision = true,     # Flag for collision checking.
          separation = true,    # Flag for node separation.
          virtualRemesh = true, # Flag for remeshing virtual nodes.
          edgeDrag = 1.0,       # Drag coefficient for edge segments.
          screwDrag = 2.0,      # Drag coefficient for screw segments.
          climbDrag = 1e10,     # Drag coefficient along the climb direction.
          lineDrag = 0.0,       # Drag coefficient along the line direction.
          mobility = mobBCC(),  # Mobility type for mobility function specialisation.
        )
DislocationP{Float64,Int64,Bool,mobBCC}(90.0, 8100.0, 0.00032, 320.0, 1600.0, 45000.0, 900000.0, 4, true, true, true, true, 1.0, 2.0, 1.0e10, 0.0, mobBCC())</code></pre><p>The integration parameters are placed into the following mutable structure.</p><pre><code class="language-julia">julia&gt; integrationP = IntegrationP(;
          dt = 1e3,
          tmin = 0.0,
          tmax = 1e10,
          method = CustomTrapezoid(),
          abstol = 1e-6,
          reltol = 1e-6,
          time = 0.0,
          step = 0,
        )
IntegrationP{Float64,CustomTrapezoid,Int64}(1000.0, 0.0, 1.0e10, CustomTrapezoid(), 1.0e-6, 1.0e-6, 0.0, 0)</code></pre><blockquote><p>[!WARNING]</p><p><code>IntegrationP</code> will undergo revisions. Probably be split into two, or perhaps eliminated completely in order to use/extend the state of the art <code>DifferentialEquations.jl</code> framework.</p></blockquote><p>Within a given material, we have multiple slip systems, which can be loaded into their own immutable structure. Here we only define a single slip system, but we have the capability of adding more by making the <code>slipPlane</code> and <code>bVec</code> arguments <code>n × 3</code> matrices rather than vectors.</p><pre><code class="language-julia">julia&gt; slipSystems = SlipSystem(;
          crystalStruct = BCC(),
          slipPlane = [1.0; 1.0; 1.0],  # Slip plane.
          bVec = [1.0; -1.0; 0.0]       # Burgers vector.
       )
SlipSystem{BCC,Array{Float64,1}}(BCC(), [1.0, 1.0, 1.0], [1.0, -1.0, 0.0])</code></pre><blockquote><p>[!WARNING]</p><p>This may change to perform validity checks regarding the relationship between burgers vector and slip plane.</p></blockquote><p>We also need dislocation sources. We make use of Julia&#39;s type system to create standard functions for loop generation. We provide a way of easily and quickly generating loops whose segments inhabit the same slip system. However, new <code>DislocationLoop()</code> methods can be made by subtyping <code>AbstractDlnStr</code>, and dispatching on the new type. One may of also course also use the default constructor and build the initial structures manually.</p><p>Here we make a regular pentagonal prismatic dislocation loop, and a regular hexagonal prismatic dislocation loop. Note that the segments may be of arbitrary length, but having asymmetric sides may result in a very ugly and irregular dislocations that may be unphysical or may end up remeshing once the simulation gets under way. As such we recommend making the segment lengths symmetric.</p><pre><code class="language-julia">julia&gt; prisPentagon = DislocationLoop(
          loopPrism();    # Prismatic loop, all segments are edge segments.
          numSides = 5,   # 5-sided loop.
          nodeSide = 1,   # One node per side, if 1 nodes will be in the corners.
          numLoops = 20,  # Number of loops of this type to generate when making a network.
          segLen = 10 * ones(5),  # Length of each segment between nodes, equal to the number of nodes.
          slipSystem = 1, # Slip System (assuming slip systems are stored in a file, this is the index).
          _slipPlane = slipSystems.slipPlane,  # Slip plane of the segments.
          _bVec = slipSystems.bVec,            # Burgers vector of the segments.
          label = nodeType[1; 2; 1; 2; 1],    # Node labels, has to be equal to the number of nodes.
          buffer = 0.0,   # Buffer to increase the dislocation spread.
          range = Float64[          # Distribution range
                        -100 100; # xmin, xmax          
                        -100 100; # ymin, ymax
                        -100 100  # zmin, zmax
                      ],
          dist = Rand(),  # Loop distribution.
      )
DislocationLoop{loopPrism,Int64,Array{Float64,1},Int64,Array{Int64,2},Array{Float64,2},Array{nodeType,1},Float64,Rand}(loopPrism(), 5, 1, 20, [10.0, 10.0, 10.0, 10.0, 10.0], 1, [1 2 … 4 5; 2 3 … 5 1], [0.5773502691896258 0.5773502691896258 … 0.5773502691896258 0.5773502691896258; 0.5773502691896258 0.5773502691896258 … 0.5773502691896258 0.5773502691896258; 0.5773502691896258 0.5773502691896258 … 0.5773502691896258 0.5773502691896258], [0.7071067811865475 0.7071067811865475 … 0.7071067811865475 0.7071067811865475; -0.7071067811865475 -0.7071067811865475 … -0.7071067811865475 -0.7071067811865475; 0.0 0.0 … 0.0 0.0], [-1.932030909139515 4.820453044614565 … -1.785143053581134 -6.014513813778146; -1.932030909139515 4.820453044614565 … -1.785143053581134 -6.014513813778146; -8.055755266097462 -5.087941102678986 … 8.123251093712414 0.10921054317980072], nodeType[DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob], 0.0, [-100.0 100.0; -100.0 100.0; -100.0 100.0], Rand())

julia&gt; shearHexagon = DislocationLoop(
          loopShear();    # Shear loop
          numSides = 6,
          nodeSide = 3,   # 3 nodes per side, it devides the side into equal segments.
          numLoops = 20,
          segLen = 10 * ones(3 * 6) / 3,  # The hexagon&#39;s side length is 10, each segment is 10/3.
          slipSystem = 1,
          _slipPlane = slipSystems.slipPlane,
          _bVec = slipSystems.bVec,
          label = nodeType[1; 2; 1; 2; 1; 2; 1; 2; 1; 2; 1; 2; 1; 2; 1; 2; 1; 2],
          buffer = 0.0,
          range = Float64[
                        -100 100;
                        -100 100;
                        -100 100
                      ],
          dist = Rand(),
      )
DislocationLoop{loopShear,Int64,Array{Float64,1},Int64,Array{Int64,2},Array{Float64,2},Array{nodeType,1},Float64,Rand}(loopShear(), 6, 3, 20, [3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335], 1, [1 2 … 17 18; 2 3 … 18 1], [0.5773502691896258 0.5773502691896258 … 0.5773502691896258 0.5773502691896258; 0.5773502691896258 0.5773502691896258 … 0.5773502691896258 0.5773502691896258; 0.5773502691896258 0.5773502691896258 … 0.5773502691896258 0.5773502691896258], [0.7071067811865475 0.7071067811865475 … 0.7071067811865475 0.7071067811865475; -0.7071067811865475 -0.7071067811865475 … -0.7071067811865475 -0.7071067811865475; 0.0 0.0 … 0.0 0.0], [5.443310539518175 6.8041381743977185 … 1.3608276348795458 4.082482904638633; -6.804138174397717 -5.443310539518174 … -6.804138174397715 -8.164965809277255; 1.3608276348795436 -1.3608276348795432
… 5.443310539518167 4.082482904638622], nodeType[DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix], 0.0, [-100.0 100.0; -100.0 100.0; -100.0 100.0], Rand())</code></pre><p>The dislocation loops will be centred about the origin, but the <code>range</code>, <code>buffer</code> and <code>dist</code> parameters will distribute the dislocations about the simulation domain once the dislocation network is generated. The type of <code>dist</code> must be a concrete subtype of <code>AbstractDistribution</code> and <code>loopDistribution()</code> method should dispatch on this concrete subtype. If a non-suported distribution is required, you only need to create a concrete subtype of <code>AbstractDistribution</code> and a new method of <code>loopDistribution()</code> to dispatch on the new type. This is all the reworking needed, since multiple dispatch will take care of any new distributions when generating the dislocation network.</p><p>Note also the array of <code>nodeType</code>, this is an enumerated type which ensures node types are limited to only those supported by the model, lowers memory footprint and increases performance.</p><p>We can then plot our loops to see our handy work. We use <code>plotlyjs()</code> because it provides a nice interactive experience, but of course, since this is Julia any plotting backend will work. Note that since they have the same slip system but one is a shear and the other a prismatic loop, they are orthogonal to each other.</p><pre><code class="language-julia">julia&gt; using Plots
julia&gt; plotlyjs()
julia&gt; fig1 = plotNodes(
          shearHexagon,
          m = 1,
          l = 3,
          linecolor = :blue,
          markercolor = :blue,
          legend = false,
        )
julia&gt; plotNodes!(fig1, prisPentagon, m = 1, l = 3,
                  linecolor = :red, markercolor = :red, legend = false)
julia&gt; plot!(fig1, camera=(100,35), size=(400,400))</code></pre><p><img src="/examples/loops.png" alt="loops"/></p><p>After generating our primitive loops, we can create a network using either a vector of dislocation loops or a single dislocation loop. The network may also be created manually, and new constructor methods may be defined for bespoke cases. For our purposes, we use the constructor that dispatches on <code>Union{DislocationLoop, AbstractVector{&lt;:DislocationLoop}}</code>, meaning a single variable whose type is <code>DislocationLoop</code> or a vector of them. Here we use a vector with both our loop structures.</p><p>Since the dislocation network is a constantly evolving entity, this necessarily means this is a mutable structure.</p><pre><code class="language-julia">julia&gt; network = DislocationNetwork(
          [shearHexagon, prisPentagon]; # Dispatch type, bespoke functions dispatch on this.
          memBuffer = 1 # Buffer for memory allocation.
       )
 DislocationNetwork{Array{Int64,2},Array{Float64,2},Array{nodeType,1},Int64,Array{Int64,2},Array{Float64,3}}([1 2 … 459 460; 2 3 … 460 456], [0.5773502691896258 0.5773502691896258 … 0.5773502691896258 0.5773502691896258; 0.5773502691896258 0.5773502691896258 … 0.5773502691896258 0.5773502691896258; 0.5773502691896258 0.5773502691896258 … 0.5773502691896258 0.5773502691896258], [0.7071067811865475 0.7071067811865475 … 0.7071067811865475 0.7071067811865475; -0.7071067811865475 -0.7071067811865475 … -0.7071067811865475 -0.7071067811865475; 0.0 0.0 … 0.0 0.0], [46.39761283211718 47.75844046699673 … -57.496002894414175 -61.72537365461118; -49.937613036904054 -48.57678540202451 … -59.28380906452193 -63.51317982471895; 41.67317243370178 38.9515171639427 … -2.1285556467706765 -10.14259619730329], nodeType[DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix  …  DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob], [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0], 460, 460, 4, [2 2 … 2 2; 1 1 … 458 459; … ; 0 0 … 0 0; 0 0 … 0 0], [1 2 … 2 2; 1 1 … 1 2], [1 1 2; 2 2 3; … ; 459 459 460; 460 460 456],
 [0.0 0.0; 0.0 0.0; 0.0 0.0]
 [0.0 0.0; 0.0 0.0; 0.0 0.0]
 [0.0 0.0; 0.0 0.0; 0.0 0.0]
 ...
 [0.0 0.0; 0.0 0.0; 0.0 0.0]
 [0.0 0.0; 0.0 0.0; 0.0 0.0]
 [0.0 0.0; 0.0 0.0; 0.0 0.0])</code></pre><p>This method automatically takes the previously defined loops and scatters them according to the parameters provided in the <code>DislocationLoop</code> structure. Furthermore, the <code>memBuffer</code> defaults to 10. The number of entries allocated for the matrices is the total number of nodes in the network times <code>memBuffer</code>. Here we allocate enough memory for all the nodes but no more. Since julia is dynamic we can allocate memory when needed. However for performance reasons it is advisable to minimise memory management as much as possible.</p><p>This function will also automatically calculate other quantities to keep track of the network&#39;s links, nodes and segments.</p><pre><code class="language-julia">julia&gt; fieldnames(typeof(network))
(:links, :slipPlane, :bVec, :coord, :label, :nodeVel, :numNode, :numSeg, :maxConnect, :connectivity, :linksConnect, :segIdx, :segForce)</code></pre><p>We can also view our network with <code>plotNodes</code>.</p><pre><code class="language-julia">julia&gt; fig2 = plotNodes(
          network,
          m = 1,
          l = 3,
          linecolor = :blue,
          markercolor = :blue,
          legend = false,
        )
julia&gt; plot!(fig2, camera=(110,40), size=(400,400))</code></pre><p><img src="/examples/network.png" alt="network"/></p><p>&lt;a name=&quot;1&quot;&gt;1&lt;/a&gt;: Immutability is translated into code performance.</p><h2 id="IO-1"><a class="docs-heading-anchor" href="#IO-1">IO</a><a class="docs-heading-anchor-permalink" href="#IO-1" title="Permalink"></a></h2><p>The package provides a way to load and save its parameters using <code>JSON</code> files. While this is <em>not</em> the most performant format for IO, it is a popular and portable, web-friendly file format that is very human readable (and therefore easy to manually create). It also produces smaller file sizes both compressed and uncompressed. Which is why it is so popular for online data sharing.</p><p><code>JSON</code> files are representations of dictionaries with <code>(key, value)</code> pairs, which are analogous to the <code>(key, value)</code> pair of structures. This makes it so any changes to any structure will automatically be taken care of by the <code>JSON</code> library. Arrays are recursively linearised into vectors of vectors using the calling language&#39;s preferred storage order. This means arrays preserve their shape and dimensionality regardless of whether the inputting or outputting language stores arrays in column- or row-major order.</p><p>They also have the added advantage of being designed for sending over the web, so they have small compressed and uncompressed file sizes, smaller than <code>BSON</code>, <code>HDF5</code> and its variants such as <code>MAT</code> and <code>JLD2</code> formats. They also aren&#39;t plagued by the portability issues these other formats have, as well as being generally easier to read, create and work with, while being within a factor of ≈3 of the aforementioned filetypes. They do however, allocate more memory than the others while being created, but the end result is half the size or less of these other file formats.</p><h3 id="Sample-JSON-File-1"><a class="docs-heading-anchor" href="#Sample-JSON-File-1">Sample JSON File</a><a class="docs-heading-anchor-permalink" href="#Sample-JSON-File-1" title="Permalink"></a></h3><p>This is a sample <code>JSON</code> file for a dislocation loop. They can be compactified by editors to decrease storage space by removing unnecessary line breaks and spaces. Here we show a somewhat longified view which is very human readable and trivially easy to create manually. Note that arrays are recursively linearised as vectors of vectors, where the linearisation follows the calling language&#39;s memory order. This means arrays will keep their shape and dimensionality regardless of the language that opens the JSON file.</p><pre><code class="language-JSON">[
  {
    &quot;loopType&quot;: &quot;DDD.loopPrism()&quot;,
    &quot;numSides&quot;: 4,
    &quot;nodeSide&quot;: 2,
    &quot;numLoops&quot;: 1,
    &quot;segLen&quot;: [1, 1, 1, 1, 1, 1, 1, 1],
    &quot;slipSystem&quot;: 1,
    &quot;label&quot;: [2, 1, 2, 1, 2, 1, 2, 1],
    &quot;buffer&quot;: 0,
    &quot;range&quot;: [[0, 0, 0], [0, 0, 0]],
    &quot;dist&quot;: &quot;DDD.Zeros()&quot;
  }
]</code></pre><p>This file describes an array, denoted by the <code>[]</code> at the top and bottom of the file, of a structure denoted by the <code>{}</code> on the second and penultimate lines. We could remove the <code>[]</code> but having all files be represent arrays (even if they are of length 1) simplifies users&#39; and developers&#39; lives by letting the same IO functions work for every case.</p><p>The keys are on the left side of the colon and the values on the right. This would get loaded to a dictionary with the same <code>(key, value)</code> pair shown here. Since the keys are the structure&#39;s field names and the values their value, everything can be easily matched to the constructor function.</p><p>Also, with since <code>JSON</code> files represent dictionaries, users can add irrelevant data to the file either as extra entries to the top level array, or into the structure definition without breaking their ability to use the file.</p><h3 id="Initialisation,-Data-Dump,-and-Reloading-1"><a class="docs-heading-anchor" href="#Initialisation,-Data-Dump,-and-Reloading-1">Initialisation, Data Dump, and Reloading</a><a class="docs-heading-anchor-permalink" href="#Initialisation,-Data-Dump,-and-Reloading-1" title="Permalink"></a></h3><p>One can load all their parameters at once like so.</p><pre><code class="language-julia">fileDislocationP = &quot;../inputs/simParams/sampleDislocationP.JSON&quot;
fileMaterialP = &quot;../inputs/simParams/sampleMaterialP.JSON&quot;
fileIntegrationP = &quot;../inputs/simParams/sampleIntegrationP.JSON&quot;
fileSlipSystem = &quot;../data/slipSystems/SlipSystems.JSON&quot;
fileDislocationLoop = &quot;../inputs/dln/samplePrismShear.JSON&quot;
dlnParams, matParams, intParams, slipSystems, dislocationLoop = loadParams(
    fileDislocationP,
    fileMaterialP,
    fileIntegrationP,
    fileSlipSystem,
    fileDislocationLoop,
)</code></pre><p>which not only loads the data but returns the aforementioned structures. If there is a single file holding all the parameters, then all the filenames would be the same, but nothing else would change as the file would be loaded into a large dictionary and only the relevant <code>(key, value)</code> pairs are used in each case.</p><p>Users may also load individual structures as follows.</p><pre><code class="language-julia">dictDislocationP = load(fileDislocationP)
dislocationP = loadDislocationP(dictDislocationP[1])

dictMaterialP = load(fileMaterialP)
materialP = loadMaterialP(dictMaterialP[1])

dictIntegrationP = load(fileIntegrationP)
integrationP = loadIntegrationP(dictIntegrationP[1])

dictSlipSystem = load(fileSlipSystem)
slipSystems = loadSlipSystem(dictSlipSystem[1])

# There can be multiple dislocation types per simulation.
dictDislocationLoop = load(fileDislocationLoop)
dislocationLoop = zeros(DislocationLoop, length(dictDislocationLoop))
for i in eachindex(dislocationLoop)
    dislocationLoop[i] = loadDislocationLoop(dictDislocationLoop[i], slipSystems)
end</code></pre><p>The reason why all the dictionary arguments of the <code>load&lt;struct_name&gt;</code> all have an index is that the files specify an array, as that keeps all files consistent with each other, particularly when saving more than one variable or constant in a single file. Individually loading files like this is useful when recovering previous save states where the data was dumped into a single file, as shown here.</p><pre><code class="language-julia"># Dump simulation parameters into a single file. Creates an array where each entry is one of the structs.
paramDump = &quot;../outputs/simParams/sampleDump.JSON&quot;
save(paramDump, dlnParams, matParams, intParams, slipSystems, dislocationLoop)

# Dump network data into a separate file.
networkDump = &quot;../outputs/dln/sampleNetwork.JSON&quot;
save(networkDump, network)

# Reload parameters.
simulation = load(paramDump)
dlnParams2 = loadDislocationP(simulation[1])
matParams2 = loadMaterialP(simulation[2])
intParams2 = loadIntegrationP(simulation[3])
slipSystems2 = loadSlipSystem(simulation[4])
dislocationLoop2 = zeros(DislocationLoop, length(simulation[5]))
for i in eachindex(dislocationLoop2)
    dislocationLoop2[i] = loadDislocationLoop(simulation[5][i], slipSystems2)
end

# Reload network.
network2 = loadNetwork(networkDump)</code></pre><p>The reason why <code>loadNetwork()</code> is different from the others is that the other values are constants, so for record keeping they would only need to be saved once per simulation. The network might have to be saved at multiple times so it gets a simpler function that calls <code>load()</code> internally.</p><h3 id="Against-the-Unbridled-Pursuit-of-Performance-1"><a class="docs-heading-anchor" href="#Against-the-Unbridled-Pursuit-of-Performance-1">Against the Unbridled Pursuit of Performance</a><a class="docs-heading-anchor-permalink" href="#Against-the-Unbridled-Pursuit-of-Performance-1" title="Permalink"></a></h3><p>For the sake of open, reproducible and portable science it is recommended users utilise <code>JSON</code> or a standard delimited file format for their IO. If IO is a performance bottleneck these are some incremental steps one should take to improve it before creating a custom IO format. Beware that your mileage may vary when using other IO formats, some may not be fully mature yet others may be abandoned in favour of better implementations.</p><ol><li>Use buffered IO.</li><li>Use Julia&#39;s in-built task and asyncronous functionality via <code>tasks</code> and <code>async</code> for either multiple IO streams or an asyncronous IO process while the other threads/cores carry on with the simulation.</li><li>Use <a href="https://github.com/JuliaIO/BSON.jl"><code>BSON</code></a>, <code>JSON</code>&#39;s binary counterpart, though this may break compatibility with other systems, particularly those with different word size and architecture. Furthermore, the binary nature of <code>BSON</code> may be used to inject code into a programme so should only be used for self-generated files.</li><li>Use <a href="https://github.com/JuliaIO/JLD2.jl"><code>JLD2</code></a>. Though the package currently says it has remained largely untested in the wild.</li><li>Use <code>DelimitedFiles</code>.</li><li>Use binary streams.</li><li>Use <a href="https://github.com/JuliaIO/Parquet.jl"><code>Parquet</code></a></li><li>Create your own format and IO stream.</li></ol><p>TO BE WRITTEN: HOW TO EXTEND METHODS TO EXPAND FUNCTIONALITY</p><h1 id="TODO-1"><a class="docs-heading-anchor" href="#TODO-1">TODO</a><a class="docs-heading-anchor-permalink" href="#TODO-1" title="Permalink"></a></h1><h2 id="Working-Objectives-1"><a class="docs-heading-anchor" href="#Working-Objectives-1">Working Objectives</a><a class="docs-heading-anchor-permalink" href="#Working-Objectives-1" title="Permalink"></a></h2><ul><li>[x] IO<ul><li>[x] Input validation<ul><li>[ ] Sensible input generators</li></ul></li><li>[ ] Performance<ul><li>[ ] Compression</li><li>[ ] Asyncronicity</li></ul></li></ul></li><li>[ ] Topology functions<ul><li>[ ] Internal Remeshing<ul><li>[ ] Coarsen mesh<ul><li>[x] Merge nodes<ul><li>[ ] Test all edge cases</li></ul></li></ul></li><li>[ ] Refine mesh<ul><li>[x] Split nodes</li></ul></li><li>[ ] Surface remeshing</li><li>[ ] Virtual node remeshing</li></ul></li></ul></li><li>[x] Self-segment force</li><li>[x] Seg-seg force<ul><li>[ ] Test tiny segment edge case</li><li>[ ] Distributed and gpu parallelisation</li></ul></li><li>[ ] PK force<ul><li>[x] Implementation</li><li>[ ] Tests</li></ul></li><li>[ ] Post processing<ul><li>[x] Plot nodes<ul><li>[ ] Asyncronicity</li></ul></li><li>[ ] Plot recipe</li><li>[ ] Statistical analysis</li></ul></li><li>[ ] Mobility function<ul><li>[ ] BCC</li><li>[ ] FCC</li></ul></li><li>[ ] Integration<ul><li>[ ] Refactor integrator structures</li><li>[ ] Look into using <a href="https://github.com/SciML/DifferentialEquations.jl">DifferentialEquations.jl</a> for structure and perhaps use/extension of methods</li><li>[ ] Make integrator</li></ul></li><li>[ ] Couple to FEM, perhaps use a package from <a href="http://www.juliafem.org/">JuliaFEM</a>.<ul><li>[ ] Mesh and FE matrices generation</li><li>[ ] Boundary conditions<ul><li>[ ] Neuman</li><li>[ ] Dirichlet</li></ul></li><li>[ ] Displacements<ul><li>[ ] Parallelisation</li></ul></li><li>[ ] Tractions<ul><li>[ ] Parallelisation</li></ul></li></ul></li></ul><h3 id="Tentative-Objectives-1"><a class="docs-heading-anchor" href="#Tentative-Objectives-1">Tentative Objectives</a><a class="docs-heading-anchor-permalink" href="#Tentative-Objectives-1" title="Permalink"></a></h3><ul><li>[ ] Custom 3-vec type, place x,y,z coordinates in contiguous memory instead of columns, ie [x1 y1 z1; x2 y2 z2] -&gt; [x1;y1;z1;x2;y2;z2], have to define custom array type, <code>getindex(arr, (a,b)) = arr[3*(a-1)+b]</code>, out of bounds and all the rest. Watch <a href="https://www.youtube.com/watch?v=jS9eouMJf_Y">this</a>.</li><li>[ ] Keep an eye on <a href="https://github.com/JuliaIO">JuliaIO</a>, <a href="https://github.com/JuliaFEM/">JuliaFEM</a>, <a href="https://github.com/sciml">SciML</a> because their methods might be useful.</li></ul></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="Dislocations/">Dislocations »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 4 June 2020 04:04">Thursday 4 June 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
