<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · DDD.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">DDD.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/dcelisgarza/DDD.jl/blob/master/docs/src/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="DDD.jl-1"><a class="docs-heading-anchor" href="#DDD.jl-1">DDD.jl</a><a class="docs-heading-anchor-permalink" href="#DDD.jl-1" title="Permalink"></a></h1><ul><li><a href="#DDD.AbstractCrystalStruct"><code>DDD.AbstractCrystalStruct</code></a></li><li><a href="#DDD.AbstractDistribution"><code>DDD.AbstractDistribution</code></a></li><li><a href="#DDD.AbstractDlnSeg"><code>DDD.AbstractDlnSeg</code></a></li><li><a href="#DDD.AbstractDlnStr"><code>DDD.AbstractDlnStr</code></a></li><li><a href="#DDD.AbstractIntegrator"><code>DDD.AbstractIntegrator</code></a></li><li><a href="#DDD.AbstractMobility"><code>DDD.AbstractMobility</code></a></li><li><a href="#DDD.DislocationLoop"><code>DDD.DislocationLoop</code></a></li><li><a href="#DDD.DislocationNetwork"><code>DDD.DislocationNetwork</code></a></li><li><a href="#DDD.DislocationP"><code>DDD.DislocationP</code></a></li><li><a href="#DDD.nodeType"><code>DDD.nodeType</code></a></li><li><a href="#Base.isequal-Tuple{Real,nodeType}"><code>Base.isequal</code></a></li><li><a href="#DDD.checkNetwork-Tuple{DislocationNetwork}"><code>DDD.checkNetwork</code></a></li><li><a href="#DDD.compStruct-Tuple{Any,Any}"><code>DDD.compStruct</code></a></li><li><a href="#DDD.coordIdx-Union{Tuple{N}, Tuple{DislocationNetwork,Union{Integer, AbstractArray{#s73,N} where #s73&lt;:Integer}}} where N"><code>DDD.coordIdx</code></a></li><li><a href="#DDD.coordLbl-Tuple{DislocationNetwork,Integer}"><code>DDD.coordLbl</code></a></li><li><a href="#DDD.dataCond-Tuple{DislocationNetwork,Symbol,Real}"><code>DDD.dataCond</code></a></li><li><a href="#DDD.extAngle-Tuple{Int64}"><code>DDD.extAngle</code></a></li><li><a href="#DDD.idxCond-Tuple{DislocationNetwork,Symbol,Function,Vararg{Any,N} where N}"><code>DDD.idxCond</code></a></li><li><a href="#DDD.idxLabel-Tuple{DislocationNetwork,Integer}"><code>DDD.idxLabel</code></a></li><li><a href="#DDD.inclusiveComparison-Tuple{Any,Vararg{Any,N} where N}"><code>DDD.inclusiveComparison</code></a></li><li><a href="#DDD.intAngle-Tuple{Int64}"><code>DDD.intAngle</code></a></li><li><a href="#DDD.limits!-Union{Tuple{N2}, Tuple{N1}, Tuple{AbstractArray{#s69,N1} where #s69&lt;:Float64,Float64,AbstractArray{#s68,N2} where #s68&lt;:Float64,Float64}} where N2 where N1"><code>DDD.limits!</code></a></li><li><a href="#DDD.loopDistribution-Tuple{Zeros,Integer,Vararg{Any,N} where N}"><code>DDD.loopDistribution</code></a></li><li><a href="#DDD.makeConnect-Union{Tuple{N}, Tuple{AbstractArray{Int64,N},Array{nodeType,1},Integer}} where N"><code>DDD.makeConnect</code></a></li><li><a href="#DDD.makeLoop-Union{Tuple{T5}, Tuple{T9}, Tuple{T8}, Tuple{T7}, Tuple{T6}, Tuple{T1}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1,T2,T2,T2,T3,T4,T2,T5,T5,T6,T7,T8,T9}} where T9&lt;:AbstractDistribution where T8&lt;:(AbstractArray{#s53,N} where #s53&lt;:Float64 where N) where T7&lt;:Float64 where T6&lt;:Array{nodeType,1} where T5&lt;:(AbstractArray{#s52,N} where #s52&lt;:Float64 where N) where T4&lt;:Union{Float64, AbstractArray{#s51,N} where #s51&lt;:Float64 where N} where T3&lt;:AbstractDlnSeg where T2&lt;:Int64 where T1&lt;:AbstractDlnStr"><code>DDD.makeLoop</code></a></li><li><a href="#DDD.makeNetwork"><code>DDD.makeNetwork</code></a></li><li><a href="#DDD.makeNetwork!"><code>DDD.makeNetwork!</code></a></li><li><a href="#DDD.makeSegment-Union{Tuple{T}, Tuple{segEdge,Array{T,1},Array{T,1}}} where T&lt;:Float64"><code>DDD.makeSegment</code></a></li><li><a href="#DDD.pushToDataFrame!-Tuple{DataFrames.DataFrame,Union{DislocationP, DDD.IntegrationP, DDD.MaterialP}}"><code>DDD.pushToDataFrame!</code></a></li><li><a href="#DDD.rot3D-Tuple{AbstractArray{#s18,1} where #s18&lt;:Float64,AbstractArray{#s19,1} where #s19&lt;:Float64,AbstractArray{#s20,1} where #s20&lt;:Float64,Float64}"><code>DDD.rot3D</code></a></li><li><a href="#DDD.saveParams-Tuple{DislocationP,DDD.MaterialP,DDD.IntegrationP,AbstractString}"><code>DDD.saveParams</code></a></li><li><a href="#DDD.translatePoints-Union{Tuple{N2}, Tuple{N1}, Tuple{AbstractArray{#s68,N1} where #s68&lt;:Float64,AbstractArray{#s67,N1} where #s67&lt;:Float64,AbstractArray{#s64,N2} where #s64&lt;:Float64}} where N2 where N1"><code>DDD.translatePoints</code></a></li><li><a href="#DDD.@makeType-Tuple{Any,Any}"><code>DDD.@makeType</code></a></li><li><a href="#DDD.@string_as_varname_macro-Tuple{AbstractString,Any}"><code>DDD.@string_as_varname_macro</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="DDD.AbstractCrystalStruct" href="#DDD.AbstractCrystalStruct"><code>DDD.AbstractCrystalStruct</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractCrystalStruct end
struct BCC &lt;:AbstractCrystalStruct end
struct FCC &lt;:AbstractCrystalStruct end
struct HCP &lt;:AbstractCrystalStruct end</code></pre><p>Crystal structures.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/2dab0e85ab7db8df27cb8f675d26726895836361/src/PrimitiveTypes.jl#LL112-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.AbstractDistribution" href="#DDD.AbstractDistribution"><code>DDD.AbstractDistribution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractDistribution end
struct Zeros &lt;: AbstractDistribution end
struct Rand &lt;: AbstractDistribution end
struct Randn &lt;: AbstractDistribution end
struct Regular &lt;: AbstractDistribution end</code></pre><p>Distributions for dislocation sources.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/2dab0e85ab7db8df27cb8f675d26726895836361/src/PrimitiveTypes.jl#LL97-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.AbstractDlnSeg" href="#DDD.AbstractDlnSeg"><code>DDD.AbstractDlnSeg</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractDlnSeg end
struct segNone &lt;: AbstractDlnSeg end
struct segEdge &lt;: AbstractDlnSeg end
struct segEdgeN &lt;: AbstractDlnSeg end
struct segScrew &lt;: AbstractDlnSeg end
struct segMixed &lt;: AbstractDlnSeg end</code></pre><p>Dislocation segment types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/2dab0e85ab7db8df27cb8f675d26726895836361/src/PrimitiveTypes.jl#LL33-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.AbstractDlnStr" href="#DDD.AbstractDlnStr"><code>DDD.AbstractDlnStr</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractDlnStr end
struct loopPrism &lt;: AbstractDlnStr end
struct loopShear &lt;: AbstractDlnStr end
struct loopDln &lt;: AbstractDlnStr end
struct loopJog &lt;: AbstractDlnStr end
struct loopKink &lt;: AbstractDlnStr end</code></pre><p>Idealised dislocation structure types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/2dab0e85ab7db8df27cb8f675d26726895836361/src/PrimitiveTypes.jl#LL79-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.AbstractIntegrator" href="#DDD.AbstractIntegrator"><code>DDD.AbstractIntegrator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractIntegrator end
struct CustomTrapezoid &lt;:AbstractIntegrator end</code></pre><p>Integrator types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/2dab0e85ab7db8df27cb8f675d26726895836361/src/PrimitiveTypes.jl#LL138-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.AbstractMobility" href="#DDD.AbstractMobility"><code>DDD.AbstractMobility</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractMobility end
struct BCC &lt;:AbstractMobility end
struct FCC &lt;:AbstractMobility end
struct HCP &lt;:AbstractMobility end</code></pre><p>Mobility functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/2dab0e85ab7db8df27cb8f675d26726895836361/src/PrimitiveTypes.jl#LL125-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.DislocationLoop" href="#DDD.DislocationLoop"><code>DDD.DislocationLoop</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DislocationLoop{
    T1 &lt;: AbstractDlnStr,
    T2 &lt;: Int64,
    T3 &lt;: Union{
        T where {T &lt;: AbstractDlnSeg},
        AbstractArray{&lt;:AbstractDlnSeg, N} where {N},
    },
    T4 &lt;: Union{
        T where {T &lt;: Float64},
        AbstractArray{&lt;:Float64, N} where {N}
    },
    T5 &lt;: Union{Int64, AbstractArray{&lt;:Int64, N} where {N}},
    T6 &lt;: AbstractArray{&lt;:Int64, N} where {N},
    T7 &lt;: AbstractArray{&lt;:Float64, N} where {N},
    T8 &lt;: Vector{&lt;:nodeType},
    T9 &lt;: Float64,
    T10 &lt;: AbstractDistribution,
}
    loopType::T1
    numSides::T2
    nodeSide::T2
    numLoops::T2
    segType::T3
    segLen::T4
    slipSystem::T5  # Slip system/systems of segments.
    links::T6       # Link matrix for dislocation nodes.
    slipPlane::T7   # Slip planes of all segments in loop.
    bVec::T7        # Burgers vector of all segments in loop.
    coord::T7       # Coords of all nodes in loop.
    label::T8
    buffer::T9
    range::T7
    dist::T10</code></pre><p>Dislocation loop structure generated via the constructor <a href="#DDD.makeLoop-Union{Tuple{T5}, Tuple{T9}, Tuple{T8}, Tuple{T7}, Tuple{T6}, Tuple{T1}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1,T2,T2,T2,T3,T4,T2,T5,T5,T6,T7,T8,T9}} where T9&lt;:AbstractDistribution where T8&lt;:(AbstractArray{#s53,N} where #s53&lt;:Float64 where N) where T7&lt;:Float64 where T6&lt;:Array{nodeType,1} where T5&lt;:(AbstractArray{#s52,N} where #s52&lt;:Float64 where N) where T4&lt;:Union{Float64, AbstractArray{#s51,N} where #s51&lt;:Float64 where N} where T3&lt;:AbstractDlnSeg where T2&lt;:Int64 where T1&lt;:AbstractDlnStr"><code>makeLoop</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/2dab0e85ab7db8df27cb8f675d26726895836361/src/DislocationType.jl#LL104-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.DislocationNetwork" href="#DDD.DislocationNetwork"><code>DDD.DislocationNetwork</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DislocationNetwork{
    T1 &lt;: AbstractArray{&lt;:Int64, N} where {N},
    T2 &lt;: AbstractArray{&lt;:Float64, N} where {N},
    T3 &lt;: Vector{nodeType},
    T4 &lt;: Int64,
    T5 &lt;: Integer,
}
    links::T1
    slipPlane::T2
    bVec::T2
    coord::T2
    label::T3
    numNode::T4 = 0     # Total number of nodes in network.
    numSeg::T4 = 0      # Total number of segs in network.
    maxConnect::T5 = 4  # Maximum connectivity of nodes.
    connectivity::T1
    linksConnect::T1</code></pre><p>Dislocation Network structure. See <a href="#DDD.DislocationLoop"><code>DislocationLoop</code></a>, <a href="#DDD.makeNetwork"><code>makeNetwork</code></a> and <a href="#DDD.makeNetwork!"><code>makeNetwork!</code></a> for further details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/2dab0e85ab7db8df27cb8f675d26726895836361/src/DislocationType.jl#LL250-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.DislocationP" href="#DDD.DislocationP"><code>DDD.DislocationP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DislocationP{
    T1 &lt;: Float64,
    T2 &lt;: Int64,
    T3 &lt;: Bool,
    T4 &lt;: AbstractMobility,
}
    # Size.
    coreRad::T1     # Core radius.
    coreRadMag::T1  # Magnitude of core Radius.
    # Connectivity.
    minSegLen::T1       # Minimum line length.
    maxSegLen::T1       # Maximum line length.
    minArea::T1         # Minimum area for remeshing.
    maxArea::T1         # Maximum area for remeshing.
    maxConnect::T2      # Maximum number of connections to a node.
    remesh::T3          # Flag for remeshing.
    collision::T3       # Flag for collision handling.
    separation::T3      # Flag for separation handling.
    virtualRemesh::T3   # Flag for virtual remeshing.
    # Mobility.
    edgeDrag::T1    # Drag coefficient edge dislocation.
    screwDrag::T1   # Drag coefficient screw dislocation.
    climbDrag::T1   # Drag coefficient climb.
    lineDrag::T1    # Drag coefficient line.
    mobility::T4    # Mobility law.</code></pre><p>Dislocation parameters structure. See <a href="#DDD.AbstractMobility"><code>AbstractMobility</code></a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/2dab0e85ab7db8df27cb8f675d26726895836361/src/DislocationType.jl#LL1-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.nodeType" href="#DDD.nodeType"><code>DDD.nodeType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">@enum nodeType begin
    undef = -1
    intMob = 0
    intFix = 1
    srfMob = 2
    srfFix = 3
    ext = 4
end</code></pre><p>Enumerated type for dislocation nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/#L0-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.checkNetwork-Tuple{DislocationNetwork}" href="#DDD.checkNetwork-Tuple{DislocationNetwork}"><code>DDD.checkNetwork</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">checkNetwork(network::DislocationNetwork)</code></pre><p>Checks the validity of the dislocation network. It ensures the following conditions are met by the member variables of <code>network</code>:</p><ol><li><code>connectivity</code> and <code>links</code> have the same number of non-zero entries;</li><li>all entries in <code>bVec</code> are non-zero;</li><li>only the trailing columns of <code>connectivity</code> are zeros;</li><li>consistency between <code>connectivity</code> and <code>links</code>;</li><li><code>bVec</code> is conserved among connected nodes;</li><li>entries in <code>links</code> are unique;</li><li>consistency betwen <code>connectivity</code> and <code>linksConnect</code></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/2dab0e85ab7db8df27cb8f675d26726895836361/src/DislocationTypeConstructors.jl#LL466-L479">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.compStruct-Tuple{Any,Any}" href="#DDD.compStruct-Tuple{Any,Any}"><code>DDD.compStruct</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compStruct(arg1, arg2)</code></pre><p>Compares structures to see if they are equal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/2dab0e85ab7db8df27cb8f675d26726895836361/src/Misc.jl#LL30-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.coordIdx-Union{Tuple{N}, Tuple{DislocationNetwork,Union{Integer, AbstractArray{#s73,N} where #s73&lt;:Integer}}} where N" href="#DDD.coordIdx-Union{Tuple{N}, Tuple{DislocationNetwork,Union{Integer, AbstractArray{#s73,N} where #s73&lt;:Integer}}} where N"><code>DDD.coordIdx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">coordIdx(network::DislocationNetwork,
    index::Union{Integer,AbstractArray{&lt;:Integer, N}) where {N}</code></pre><p>Get coordinates for the node(s) that with the <code>index</code> or vector of indices provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/2dab0e85ab7db8df27cb8f675d26726895836361/src/DislocationIdx.jl#LL25-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.coordLbl-Tuple{DislocationNetwork,Integer}" href="#DDD.coordLbl-Tuple{DislocationNetwork,Integer}"><code>DDD.coordLbl</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Related functions: <a href="#DDD.idxLabel-Tuple{DislocationNetwork,Integer}"><code>idxLabel</code></a></p><pre><code class="language-none">coordLbl(network::DislocationNetwork, label::Integer)</code></pre><p>Get coordinates for the nodes with a given label (node type).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/2dab0e85ab7db8df27cb8f675d26726895836361/src/DislocationIdx.jl#LL15-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.dataCond-Tuple{DislocationNetwork,Symbol,Real}" href="#DDD.dataCond-Tuple{DislocationNetwork,Symbol,Real}"><code>DDD.dataCond</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Related functions: <code>idxCond</code></p><pre><code class="language-none">dataCond(network::DislocationNetwork, dataField::Symbol, val::Real;
    condition::Function = ==)</code></pre><p>Get the data whose <code>dataField</code>, <code>(:links, :bVec, :slipPlane, :coord, :label, :numNode, :numSeg)</code>, meets the <code>condition(dataField, val)</code>. If <code>dataField</code> is multidimensional it will use <code>CartesianIndex</code> to find it.</p><pre><code class="language-none">dataCond(network::DislocationNetwork, dataField::Symbol, idxComp::Integer,
    val::Real; condition::Function = ==)</code></pre><p>Get the data whose <code>dataField</code>, meets the <code>condition(dataField[:,idxComp], val)</code>. It errors if the fieldname provided does not have a column <code>idxComp</code>.</p><pre><code class="language-none">dataCond(network::DislocationNetwork, dataField::Symbol, condField::Symbol,
    val::Real; condition::Function = ==)</code></pre><p>Get the data from <code>dataField</code> that corresponds to the <code>condField</code> (from the same pool as <code>dataField</code>) that meets the <code>condition(condField, val)</code>. If <code>condField</code> is multidimensional it will use <code>CartesianIndex</code> in its search. <code>dataField</code> and <code>condField</code> must have the same number of rows.</p><pre><code class="language-none">dataCond(network::DislocationNetwork, dataField::Symbol, condField::Symbol,
    idxComp::Integer, val::Real; condition::Function = ==)</code></pre><p>Get the data from <code>dataField</code> that corresponds to the <code>condField</code> that meets the <code>condition(condField[:, idxComp], val)</code>. <code>dataField</code> and <code>condField</code> must have the same number of rows.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/2dab0e85ab7db8df27cb8f675d26726895836361/src/DislocationIdx.jl#LL100-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.extAngle-Tuple{Int64}" href="#DDD.extAngle-Tuple{Int64}"><code>DDD.extAngle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">extAngle(n::Int64)</code></pre><p>Calculates the exterior angle of a regular polygon with <code>n</code> sides.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/2dab0e85ab7db8df27cb8f675d26726895836361/src/Misc.jl#LL80-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.idxCond-Tuple{DislocationNetwork,Symbol,Function,Vararg{Any,N} where N}" href="#DDD.idxCond-Tuple{DislocationNetwork,Symbol,Function,Vararg{Any,N} where N}"><code>DDD.idxCond</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Related functions: <a href="#DDD.dataCond-Tuple{DislocationNetwork,Symbol,Real}"><code>dataCond</code></a></p><pre><code class="language-none">idxCond(network::DislocationNetwork, fieldname::Symbol,
    args...; condition::Function)</code></pre><p>Find index/indices whose <code>fieldname</code> meets the <code>condition(fieldname, args...)</code> where condition can be any function that uses <code>fieldname</code> and <code>args</code> to make a comparison.</p><pre><code class="language-none">idxCond(data::Union{
        AbstractArray{&lt;:Real,N1},
        AbstractArray{&lt;:nodeType, {N2}}
    },
    val::Real; condition::Function = ==) where {N1,N2}</code></pre><p>Find index/indices of data that meet the condition(data, val).</p><pre><code class="language-none">idxCond(network::DislocationNetwork, fieldname::Symbol, val::Real;
    condition::Function = ==)</code></pre><p>Find index/indices of node whose <code>fieldname</code>, <code>(:links, :bVec, :slipPlane, :coord, :label, :numNode, :numSeg)</code>, meets <code>condition(fieldname, val)</code>. If <code>fieldName</code> is multidimensional it will return <code>CartesianIndex</code>.</p><pre><code class="language-none">idxCond(network::DislocationNetwork, fieldname::Symbol, idxComp::Integer,
    val::Real; condition::Function = ==)</code></pre><p>Find index/indices of node whose <code>fieldname</code> meets <code>condition(fieldname[:, idxComp], val)</code>. It errors if the fieldname provided does not have a column <code>idxComp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/2dab0e85ab7db8df27cb8f675d26726895836361/src/DislocationIdx.jl#LL39-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.idxLabel-Tuple{DislocationNetwork,Integer}" href="#DDD.idxLabel-Tuple{DislocationNetwork,Integer}"><code>DDD.idxLabel</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Related functions: <a href="#DDD.coordLbl-Tuple{DislocationNetwork,Integer}"><code>coordLbl</code></a></p><pre><code class="language-none">idxLabel(network::DislocationNetwork, label::Integer; condition::Function = ==)</code></pre><p>Find indices for dislocations whose <code>label</code> meets <code>condition(x, label)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/2dab0e85ab7db8df27cb8f675d26726895836361/src/DislocationIdx.jl#LL1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.inclusiveComparison-Tuple{Any,Vararg{Any,N} where N}" href="#DDD.inclusiveComparison-Tuple{Any,Vararg{Any,N} where N}"><code>DDD.inclusiveComparison</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inclusiveComparison(data, args...)</code></pre><p>Compare data to a tuple, return <code>true</code> if it is equal to any arg, <code>false</code> if it is not equal to any.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/2dab0e85ab7db8df27cb8f675d26726895836361/src/Misc.jl#LL16-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.intAngle-Tuple{Int64}" href="#DDD.intAngle-Tuple{Int64}"><code>DDD.intAngle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">intAngle(n::Int64)</code></pre><p>Calculates the interior angle of a regular polygon with <code>n</code> sides.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/2dab0e85ab7db8df27cb8f675d26726895836361/src/Misc.jl#LL71-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.loopDistribution-Tuple{Zeros,Integer,Vararg{Any,N} where N}" href="#DDD.loopDistribution-Tuple{Zeros,Integer,Vararg{Any,N} where N}"><code>DDD.loopDistribution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">loopDistribution(dist&lt;:AbstractDistribution, n::Integer, args...; kw...)</code></pre><p>Returns <code>n</code> points according to the concrete subtype of <a href="#DDD.AbstractDistribution"><code>AbstractDistribution</code></a> given. Overload this function with new concrete subtypes and custom distributions. This and <a href="#DDD.limits!-Union{Tuple{N2}, Tuple{N1}, Tuple{AbstractArray{#s69,N1} where #s69&lt;:Float64,Float64,AbstractArray{#s68,N2} where #s68&lt;:Float64,Float64}} where N2 where N1"><code>limits!</code></a> are used in <a href="#DDD.translatePoints-Union{Tuple{N2}, Tuple{N1}, Tuple{AbstractArray{#s68,N1} where #s68&lt;:Float64,AbstractArray{#s67,N1} where #s67&lt;:Float64,AbstractArray{#s64,N2} where #s64&lt;:Float64}} where N2 where N1"><code>translatePoints</code></a> to distribute dislocations in the simulation domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/2dab0e85ab7db8df27cb8f675d26726895836361/src/DislocationTypeConstructors.jl#LL358-L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.makeConnect-Union{Tuple{N}, Tuple{AbstractArray{Int64,N},Array{nodeType,1},Integer}} where N" href="#DDD.makeConnect-Union{Tuple{N}, Tuple{AbstractArray{Int64,N},Array{nodeType,1},Integer}} where N"><code>DDD.makeConnect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">makeConnect(
    links::AbstractArray{Int64, N},
    label::Vector{nodeType},
    maxConnect::Integer,
) where {N}</code></pre><p>Returns tuple of matrices <code>connectivity</code> and <code>linksConnect</code>. <code>connectivity</code> contains the number of other other nodes each node is connected to, up to <code>maxConnect</code> other nodes. It also contains the segments in which it&#39;s involved. <code>linksConnect</code> is the running total of the number of other nodes each node is connected to, will probably be deleted in the future. This is called from <a href="#DDD.makeNetwork"><code>makeNetwork</code></a> and <a href="#DDD.makeNetwork!"><code>makeNetwork!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/2dab0e85ab7db8df27cb8f675d26726895836361/src/DislocationTypeConstructors.jl#LL425-L434">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.makeLoop-Union{Tuple{T5}, Tuple{T9}, Tuple{T8}, Tuple{T7}, Tuple{T6}, Tuple{T1}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1,T2,T2,T2,T3,T4,T2,T5,T5,T6,T7,T8,T9}} where T9&lt;:AbstractDistribution where T8&lt;:(AbstractArray{#s53,N} where #s53&lt;:Float64 where N) where T7&lt;:Float64 where T6&lt;:Array{nodeType,1} where T5&lt;:(AbstractArray{#s52,N} where #s52&lt;:Float64 where N) where T4&lt;:Union{Float64, AbstractArray{#s51,N} where #s51&lt;:Float64 where N} where T3&lt;:AbstractDlnSeg where T2&lt;:Int64 where T1&lt;:AbstractDlnStr" href="#DDD.makeLoop-Union{Tuple{T5}, Tuple{T9}, Tuple{T8}, Tuple{T7}, Tuple{T6}, Tuple{T1}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1,T2,T2,T2,T3,T4,T2,T5,T5,T6,T7,T8,T9}} where T9&lt;:AbstractDistribution where T8&lt;:(AbstractArray{#s53,N} where #s53&lt;:Float64 where N) where T7&lt;:Float64 where T6&lt;:Array{nodeType,1} where T5&lt;:(AbstractArray{#s52,N} where #s52&lt;:Float64 where N) where T4&lt;:Union{Float64, AbstractArray{#s51,N} where #s51&lt;:Float64 where N} where T3&lt;:AbstractDlnSeg where T2&lt;:Int64 where T1&lt;:AbstractDlnStr"><code>DDD.makeLoop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">makeLoop(
    loopType::T1,   # Type of loop.
    numSides::T2,   # Number of sides in loop, must be even.
    nodeSide::T2,   # Nodes per side.
    numLoops::T2,   # Number of loops in initial network.
    segType::T3,    # Type of segments in loop (future-proofing).
    segLen::T4,     # Lengths of half the segments in loop, why `numSides` must be even.
    slipSystem::T2, # Index of the loop&#39;s slip system.
    _slipPlane::T5, # Slip plane vector.
    _bVec::T5,      # Burgers vector.
    label::T6,      # Labels, length must be equal to `numSides * nodeSide`.
    buffer::T7,     # Buffer distance to prevent overlap.
    range::T8,      # Spatial range of `dist`, defines the space occupied by the loops in the network.
    dist::T9,       # Spatial distribution of loops in `range`.
) where {
    T1 &lt;: AbstractDlnStr, # Dislocation structure.
    T2 &lt;: Int64,
    T3 &lt;: AbstractDlnSeg, # Dislocation segment type.
    T4 &lt;: Union{
        T where {T &lt;: Float64},
        AbstractArray{&lt;:Float64, N} where {N}
    },
    T5 &lt;: AbstractArray{&lt;:Float64, N} where {N},
    T6 &lt;: Vector{nodeType}, # Dislocation node enumerated type.
    T7 &lt;: Float64,
    T8 &lt;: AbstractArray{&lt;:Float64, N} where {N},
    T9 &lt;: AbstractDistribution, # Spatial distribution type, defines the loops&#39; spatial distribution in the network.
}</code></pre><p>Constructor function for <a href="#DDD.DislocationLoop"><code>DislocationLoop</code></a>. See <a href="#DDD.AbstractDlnStr"><code>AbstractDlnStr</code></a>, <a href="#DDD.AbstractDlnSeg"><code>AbstractDlnSeg</code></a>, <a href="#DDD.nodeType"><code>nodeType</code></a>, <a href="#DDD.AbstractDistribution"><code>AbstractDistribution</code></a> for further details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/2dab0e85ab7db8df27cb8f675d26726895836361/src/DislocationTypeConstructors.jl#LL51-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.makeNetwork" href="#DDD.makeNetwork"><code>DDD.makeNetwork</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">makeNetwork(
    sources::Union{
            DislocationLoop,
            AbstractVector{&lt;:DislocationLoop}
        }, # Dislocation structures.
    maxConnect::Integer = 4,
    memBuffer::Integer = 10, # Buffer for memory allocation. The code will allocate the total number of nodes times `memBuffer` to reduce dynamic memory allocation during runtime.
    args...;
    checkConsistency::Bool = false, # Check the consistency of the network.
    kw...,
)</code></pre><p>Constructor for <a href="#DDD.DislocationNetwork"><code>DislocationNetwork</code></a>, see <a href="#DDD.makeNetwork!"><code>makeNetwork!</code></a> for in-place version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/2dab0e85ab7db8df27cb8f675d26726895836361/src/DislocationTypeConstructors.jl#LL184-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.makeNetwork!" href="#DDD.makeNetwork!"><code>DDD.makeNetwork!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">makeNetwork!(
    network::DislocationNetwork,
    sources::Union{
        DislocationLoop,
        AbstractVector{&lt;:DislocationLoop}
    },
    maxConnect::Integer = 4,
    args...;
    checkConsistency::Bool = false,
    kw...,
)</code></pre><p>In-place constructor for <a href="#DDD.DislocationNetwork"><code>DislocationNetwork</code></a>, see <a href="#DDD.makeNetwork"><code>makeNetwork</code></a> for constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/2dab0e85ab7db8df27cb8f675d26726895836361/src/DislocationTypeConstructors.jl#LL272-L287">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.makeSegment-Union{Tuple{T}, Tuple{segEdge,Array{T,1},Array{T,1}}} where T&lt;:Float64" href="#DDD.makeSegment-Union{Tuple{T}, Tuple{segEdge,Array{T,1},Array{T,1}}} where T&lt;:Float64"><code>DDD.makeSegment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">makeSegment(type::AbstractDlnSeg, slipPlane::Vector{T}, bVec::Vector{T}) where {T&lt;:Float64}</code></pre><p>Make segment depending on the segment type, see <a href="#DDD.AbstractDlnSeg"><code>AbstractDlnSeg</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/2dab0e85ab7db8df27cb8f675d26726895836361/src/PrimitiveTypes.jl#LL50-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.rot3D-Tuple{AbstractArray{#s18,1} where #s18&lt;:Float64,AbstractArray{#s19,1} where #s19&lt;:Float64,AbstractArray{#s20,1} where #s20&lt;:Float64,Float64}" href="#DDD.rot3D-Tuple{AbstractArray{#s18,1} where #s18&lt;:Float64,AbstractArray{#s19,1} where #s19&lt;:Float64,AbstractArray{#s20,1} where #s20&lt;:Float64,Float64}"><code>DDD.rot3D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rot3D(xyz::Vector{&lt;:Float64}, uvw::Vector{Float64}, abc::Vector{&lt;:Float64},
    θ::Float64)</code></pre><p>Rotate point <code>xyz</code> about the line with direction vector <code>uvw</code> that crosses the point <code>abc</code> by the angle <code>θ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/2dab0e85ab7db8df27cb8f675d26726895836361/src/Misc.jl#LL89-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.saveParams-Tuple{DislocationP,DDD.MaterialP,DDD.IntegrationP,AbstractString}" href="#DDD.saveParams-Tuple{DislocationP,DDD.MaterialP,DDD.IntegrationP,AbstractString}"><code>DDD.saveParams</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Saves simulation parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/2dab0e85ab7db8df27cb8f675d26726895836361/src/Output.jl#LL14-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isequal-Tuple{Real,nodeType}" href="#Base.isequal-Tuple{Real,nodeType}"><code>Base.isequal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Overloaded functions for dislocation <code>nodeType</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/2dab0e85ab7db8df27cb8f675d26726895836361/src/PrimitiveTypes.jl#LL22-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.limits!-Union{Tuple{N2}, Tuple{N1}, Tuple{AbstractArray{#s69,N1} where #s69&lt;:Float64,Float64,AbstractArray{#s68,N2} where #s68&lt;:Float64,Float64}} where N2 where N1" href="#DDD.limits!-Union{Tuple{N2}, Tuple{N1}, Tuple{AbstractArray{#s69,N1} where #s69&lt;:Float64,Float64,AbstractArray{#s68,N2} where #s68&lt;:Float64,Float64}} where N2 where N1"><code>DDD.limits!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">limits!(
    lims::AbstractArray{&lt;:Float64, N1},
    segLen::Float64,
    range::AbstractArray{&lt;:Float64, N2},
    buffer::Float64,
) where {N1, N2}</code></pre><p>Calculate the spatial limits a dislocation will occupy. This and <a href="#DDD.loopDistribution-Tuple{Zeros,Integer,Vararg{Any,N} where N}"><code>loopDistribution</code></a> are used in <a href="#DDD.translatePoints-Union{Tuple{N2}, Tuple{N1}, Tuple{AbstractArray{#s68,N1} where #s68&lt;:Float64,AbstractArray{#s67,N1} where #s67&lt;:Float64,AbstractArray{#s64,N2} where #s64&lt;:Float64}} where N2 where N1"><code>translatePoints</code></a> to distribute dislocations in the simulation domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/2dab0e85ab7db8df27cb8f675d26726895836361/src/DislocationTypeConstructors.jl#LL377-L387">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.pushToDataFrame!-Tuple{DataFrames.DataFrame,Union{DislocationP, DDD.IntegrationP, DDD.MaterialP}}" href="#DDD.pushToDataFrame!-Tuple{DataFrames.DataFrame,Union{DislocationP, DDD.IntegrationP, DDD.MaterialP}}"><code>DDD.pushToDataFrame!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pushes data to a dataframe for saving later.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/2dab0e85ab7db8df27cb8f675d26726895836361/src/Output.jl#LL1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.translatePoints-Union{Tuple{N2}, Tuple{N1}, Tuple{AbstractArray{#s68,N1} where #s68&lt;:Float64,AbstractArray{#s67,N1} where #s67&lt;:Float64,AbstractArray{#s64,N2} where #s64&lt;:Float64}} where N2 where N1" href="#DDD.translatePoints-Union{Tuple{N2}, Tuple{N1}, Tuple{AbstractArray{#s68,N1} where #s68&lt;:Float64,AbstractArray{#s67,N1} where #s67&lt;:Float64,AbstractArray{#s64,N2} where #s64&lt;:Float64}} where N2 where N1"><code>DDD.translatePoints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function translatePoints(
    coord::AbstractArray{&lt;:Float64, N1},
    lims::AbstractArray{&lt;:Float64, N1},
    disp::AbstractArray{&lt;:Float64, N2},
) where {N1, N2}</code></pre><p>Translate dislocation node coordinates <code>coord</code> inside the spatial bounds of <code>lims</code> (calculated in <a href="#DDD.limits!-Union{Tuple{N2}, Tuple{N1}, Tuple{AbstractArray{#s69,N1} where #s69&lt;:Float64,Float64,AbstractArray{#s68,N2} where #s68&lt;:Float64,Float64}} where N2 where N1"><code>limits!</code></a>) according to the displacement <code>disp</code> (calculated in <a href="#DDD.loopDistribution-Tuple{Zeros,Integer,Vararg{Any,N} where N}"><code>loopDistribution</code></a>). Used to distribute sources inside a domain in <a href="#DDD.makeNetwork"><code>makeNetwork</code></a> and <a href="#DDD.makeNetwork!"><code>makeNetwork!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/2dab0e85ab7db8df27cb8f675d26726895836361/src/DislocationTypeConstructors.jl#LL402-L411">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.@makeType-Tuple{Any,Any}" href="#DDD.@makeType-Tuple{Any,Any}"><code>DDD.@makeType</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">makeType(type::Any, supertype::Any)</code></pre><p>Macro to make a <code>type</code> that is a subtype of <code>supertype</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/2dab0e85ab7db8df27cb8f675d26726895836361/src/Misc.jl#LL47-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DDD.@string_as_varname_macro-Tuple{AbstractString,Any}" href="#DDD.@string_as_varname_macro-Tuple{AbstractString,Any}"><code>DDD.@string_as_varname_macro</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">string_as_varname_macro(s::AbstractString, v::Any)</code></pre><p>Turn a string <code>s</code> into a variable whose name is the string <code>s</code> and value is <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/DDD.jl/blob/2dab0e85ab7db8df27cb8f675d26726895836361/src/Misc.jl#LL61-L66">source</a></section></article></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 30 March 2020 00:17">Monday 30 March 2020</span>. Using Julia version 1.4.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
